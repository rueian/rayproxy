// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: src/ray/protobuf/core_worker.proto

package protobuf

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// CoreWorkerServiceClient is the client API for CoreWorkerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CoreWorkerServiceClient interface {
	// Push a task directly to this worker from another.
	PushTask(ctx context.Context, in *PushTaskRequest, opts ...grpc.CallOption) (*PushTaskReply, error)
	// Reply from raylet that wait for direct actor call args has completed.
	DirectActorCallArgWaitComplete(ctx context.Context, in *DirectActorCallArgWaitCompleteRequest, opts ...grpc.CallOption) (*DirectActorCallArgWaitCompleteReply, error)
	// Ask the object's owner about the object's current status.
	GetObjectStatus(ctx context.Context, in *GetObjectStatusRequest, opts ...grpc.CallOption) (*GetObjectStatusReply, error)
	// Wait for the actor's owner to decide that the actor has gone out of scope.
	// Replying to this message indicates that the client should force-kill the
	// actor process, if still alive.
	WaitForActorOutOfScope(ctx context.Context, in *WaitForActorOutOfScopeRequest, opts ...grpc.CallOption) (*WaitForActorOutOfScopeReply, error)
	// / The long polling request sent to the core worker for pubsub operations.
	// / It is replied once there are batch of objects that need to be published to
	// / the caller (subscriber).
	PubsubLongPolling(ctx context.Context, in *PubsubLongPollingRequest, opts ...grpc.CallOption) (*PubsubLongPollingReply, error)
	// / The pubsub command batch request used by the subscriber.
	PubsubCommandBatch(ctx context.Context, in *PubsubCommandBatchRequest, opts ...grpc.CallOption) (*PubsubCommandBatchReply, error)
	// Update the batched object location information to the ownership-based object
	// directory.
	UpdateObjectLocationBatch(ctx context.Context, in *UpdateObjectLocationBatchRequest, opts ...grpc.CallOption) (*UpdateObjectLocationBatchReply, error)
	// Get object locations from the ownership-based object directory.
	GetObjectLocationsOwner(ctx context.Context, in *GetObjectLocationsOwnerRequest, opts ...grpc.CallOption) (*GetObjectLocationsOwnerReply, error)
	// Request that the worker shut down without completing outstanding work.
	KillActor(ctx context.Context, in *KillActorRequest, opts ...grpc.CallOption) (*KillActorReply, error)
	// Request that a worker cancels a task.
	CancelTask(ctx context.Context, in *CancelTaskRequest, opts ...grpc.CallOption) (*CancelTaskReply, error)
	// Request for a worker to issue a cancelation.
	RemoteCancelTask(ctx context.Context, in *RemoteCancelTaskRequest, opts ...grpc.CallOption) (*RemoteCancelTaskReply, error)
	// Get metrics from core workers.
	GetCoreWorkerStats(ctx context.Context, in *GetCoreWorkerStatsRequest, opts ...grpc.CallOption) (*GetCoreWorkerStatsReply, error)
	// Trigger local GC on the worker.
	LocalGC(ctx context.Context, in *LocalGCRequest, opts ...grpc.CallOption) (*LocalGCReply, error)
	// Spill objects to external storage. Caller: raylet; callee: I/O worker.
	SpillObjects(ctx context.Context, in *SpillObjectsRequest, opts ...grpc.CallOption) (*SpillObjectsReply, error)
	// Restore spilled objects from external storage. Caller: raylet; callee: I/O worker.
	RestoreSpilledObjects(ctx context.Context, in *RestoreSpilledObjectsRequest, opts ...grpc.CallOption) (*RestoreSpilledObjectsReply, error)
	// Delete spilled objects from external storage. Caller: raylet; callee: I/O worker.
	DeleteSpilledObjects(ctx context.Context, in *DeleteSpilledObjectsRequest, opts ...grpc.CallOption) (*DeleteSpilledObjectsReply, error)
	// Notification from raylet that an object ID is available in local plasma.
	PlasmaObjectReady(ctx context.Context, in *PlasmaObjectReadyRequest, opts ...grpc.CallOption) (*PlasmaObjectReadyReply, error)
	// Request for a worker to exit.
	Exit(ctx context.Context, in *ExitRequest, opts ...grpc.CallOption) (*ExitReply, error)
	// Assign the owner of an object to the intended worker.
	AssignObjectOwner(ctx context.Context, in *AssignObjectOwnerRequest, opts ...grpc.CallOption) (*AssignObjectOwnerReply, error)
}

type coreWorkerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCoreWorkerServiceClient(cc grpc.ClientConnInterface) CoreWorkerServiceClient {
	return &coreWorkerServiceClient{cc}
}

func (c *coreWorkerServiceClient) PushTask(ctx context.Context, in *PushTaskRequest, opts ...grpc.CallOption) (*PushTaskReply, error) {
	out := new(PushTaskReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.CoreWorkerService/PushTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreWorkerServiceClient) DirectActorCallArgWaitComplete(ctx context.Context, in *DirectActorCallArgWaitCompleteRequest, opts ...grpc.CallOption) (*DirectActorCallArgWaitCompleteReply, error) {
	out := new(DirectActorCallArgWaitCompleteReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.CoreWorkerService/DirectActorCallArgWaitComplete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreWorkerServiceClient) GetObjectStatus(ctx context.Context, in *GetObjectStatusRequest, opts ...grpc.CallOption) (*GetObjectStatusReply, error) {
	out := new(GetObjectStatusReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.CoreWorkerService/GetObjectStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreWorkerServiceClient) WaitForActorOutOfScope(ctx context.Context, in *WaitForActorOutOfScopeRequest, opts ...grpc.CallOption) (*WaitForActorOutOfScopeReply, error) {
	out := new(WaitForActorOutOfScopeReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.CoreWorkerService/WaitForActorOutOfScope", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreWorkerServiceClient) PubsubLongPolling(ctx context.Context, in *PubsubLongPollingRequest, opts ...grpc.CallOption) (*PubsubLongPollingReply, error) {
	out := new(PubsubLongPollingReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.CoreWorkerService/PubsubLongPolling", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreWorkerServiceClient) PubsubCommandBatch(ctx context.Context, in *PubsubCommandBatchRequest, opts ...grpc.CallOption) (*PubsubCommandBatchReply, error) {
	out := new(PubsubCommandBatchReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.CoreWorkerService/PubsubCommandBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreWorkerServiceClient) UpdateObjectLocationBatch(ctx context.Context, in *UpdateObjectLocationBatchRequest, opts ...grpc.CallOption) (*UpdateObjectLocationBatchReply, error) {
	out := new(UpdateObjectLocationBatchReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.CoreWorkerService/UpdateObjectLocationBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreWorkerServiceClient) GetObjectLocationsOwner(ctx context.Context, in *GetObjectLocationsOwnerRequest, opts ...grpc.CallOption) (*GetObjectLocationsOwnerReply, error) {
	out := new(GetObjectLocationsOwnerReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.CoreWorkerService/GetObjectLocationsOwner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreWorkerServiceClient) KillActor(ctx context.Context, in *KillActorRequest, opts ...grpc.CallOption) (*KillActorReply, error) {
	out := new(KillActorReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.CoreWorkerService/KillActor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreWorkerServiceClient) CancelTask(ctx context.Context, in *CancelTaskRequest, opts ...grpc.CallOption) (*CancelTaskReply, error) {
	out := new(CancelTaskReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.CoreWorkerService/CancelTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreWorkerServiceClient) RemoteCancelTask(ctx context.Context, in *RemoteCancelTaskRequest, opts ...grpc.CallOption) (*RemoteCancelTaskReply, error) {
	out := new(RemoteCancelTaskReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.CoreWorkerService/RemoteCancelTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreWorkerServiceClient) GetCoreWorkerStats(ctx context.Context, in *GetCoreWorkerStatsRequest, opts ...grpc.CallOption) (*GetCoreWorkerStatsReply, error) {
	out := new(GetCoreWorkerStatsReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.CoreWorkerService/GetCoreWorkerStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreWorkerServiceClient) LocalGC(ctx context.Context, in *LocalGCRequest, opts ...grpc.CallOption) (*LocalGCReply, error) {
	out := new(LocalGCReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.CoreWorkerService/LocalGC", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreWorkerServiceClient) SpillObjects(ctx context.Context, in *SpillObjectsRequest, opts ...grpc.CallOption) (*SpillObjectsReply, error) {
	out := new(SpillObjectsReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.CoreWorkerService/SpillObjects", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreWorkerServiceClient) RestoreSpilledObjects(ctx context.Context, in *RestoreSpilledObjectsRequest, opts ...grpc.CallOption) (*RestoreSpilledObjectsReply, error) {
	out := new(RestoreSpilledObjectsReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.CoreWorkerService/RestoreSpilledObjects", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreWorkerServiceClient) DeleteSpilledObjects(ctx context.Context, in *DeleteSpilledObjectsRequest, opts ...grpc.CallOption) (*DeleteSpilledObjectsReply, error) {
	out := new(DeleteSpilledObjectsReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.CoreWorkerService/DeleteSpilledObjects", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreWorkerServiceClient) PlasmaObjectReady(ctx context.Context, in *PlasmaObjectReadyRequest, opts ...grpc.CallOption) (*PlasmaObjectReadyReply, error) {
	out := new(PlasmaObjectReadyReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.CoreWorkerService/PlasmaObjectReady", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreWorkerServiceClient) Exit(ctx context.Context, in *ExitRequest, opts ...grpc.CallOption) (*ExitReply, error) {
	out := new(ExitReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.CoreWorkerService/Exit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreWorkerServiceClient) AssignObjectOwner(ctx context.Context, in *AssignObjectOwnerRequest, opts ...grpc.CallOption) (*AssignObjectOwnerReply, error) {
	out := new(AssignObjectOwnerReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.CoreWorkerService/AssignObjectOwner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CoreWorkerServiceServer is the server API for CoreWorkerService service.
// All implementations should embed UnimplementedCoreWorkerServiceServer
// for forward compatibility
type CoreWorkerServiceServer interface {
	// Push a task directly to this worker from another.
	PushTask(context.Context, *PushTaskRequest) (*PushTaskReply, error)
	// Reply from raylet that wait for direct actor call args has completed.
	DirectActorCallArgWaitComplete(context.Context, *DirectActorCallArgWaitCompleteRequest) (*DirectActorCallArgWaitCompleteReply, error)
	// Ask the object's owner about the object's current status.
	GetObjectStatus(context.Context, *GetObjectStatusRequest) (*GetObjectStatusReply, error)
	// Wait for the actor's owner to decide that the actor has gone out of scope.
	// Replying to this message indicates that the client should force-kill the
	// actor process, if still alive.
	WaitForActorOutOfScope(context.Context, *WaitForActorOutOfScopeRequest) (*WaitForActorOutOfScopeReply, error)
	// / The long polling request sent to the core worker for pubsub operations.
	// / It is replied once there are batch of objects that need to be published to
	// / the caller (subscriber).
	PubsubLongPolling(context.Context, *PubsubLongPollingRequest) (*PubsubLongPollingReply, error)
	// / The pubsub command batch request used by the subscriber.
	PubsubCommandBatch(context.Context, *PubsubCommandBatchRequest) (*PubsubCommandBatchReply, error)
	// Update the batched object location information to the ownership-based object
	// directory.
	UpdateObjectLocationBatch(context.Context, *UpdateObjectLocationBatchRequest) (*UpdateObjectLocationBatchReply, error)
	// Get object locations from the ownership-based object directory.
	GetObjectLocationsOwner(context.Context, *GetObjectLocationsOwnerRequest) (*GetObjectLocationsOwnerReply, error)
	// Request that the worker shut down without completing outstanding work.
	KillActor(context.Context, *KillActorRequest) (*KillActorReply, error)
	// Request that a worker cancels a task.
	CancelTask(context.Context, *CancelTaskRequest) (*CancelTaskReply, error)
	// Request for a worker to issue a cancelation.
	RemoteCancelTask(context.Context, *RemoteCancelTaskRequest) (*RemoteCancelTaskReply, error)
	// Get metrics from core workers.
	GetCoreWorkerStats(context.Context, *GetCoreWorkerStatsRequest) (*GetCoreWorkerStatsReply, error)
	// Trigger local GC on the worker.
	LocalGC(context.Context, *LocalGCRequest) (*LocalGCReply, error)
	// Spill objects to external storage. Caller: raylet; callee: I/O worker.
	SpillObjects(context.Context, *SpillObjectsRequest) (*SpillObjectsReply, error)
	// Restore spilled objects from external storage. Caller: raylet; callee: I/O worker.
	RestoreSpilledObjects(context.Context, *RestoreSpilledObjectsRequest) (*RestoreSpilledObjectsReply, error)
	// Delete spilled objects from external storage. Caller: raylet; callee: I/O worker.
	DeleteSpilledObjects(context.Context, *DeleteSpilledObjectsRequest) (*DeleteSpilledObjectsReply, error)
	// Notification from raylet that an object ID is available in local plasma.
	PlasmaObjectReady(context.Context, *PlasmaObjectReadyRequest) (*PlasmaObjectReadyReply, error)
	// Request for a worker to exit.
	Exit(context.Context, *ExitRequest) (*ExitReply, error)
	// Assign the owner of an object to the intended worker.
	AssignObjectOwner(context.Context, *AssignObjectOwnerRequest) (*AssignObjectOwnerReply, error)
}

// UnimplementedCoreWorkerServiceServer should be embedded to have forward compatible implementations.
type UnimplementedCoreWorkerServiceServer struct {
}

func (UnimplementedCoreWorkerServiceServer) PushTask(context.Context, *PushTaskRequest) (*PushTaskReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushTask not implemented")
}
func (UnimplementedCoreWorkerServiceServer) DirectActorCallArgWaitComplete(context.Context, *DirectActorCallArgWaitCompleteRequest) (*DirectActorCallArgWaitCompleteReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DirectActorCallArgWaitComplete not implemented")
}
func (UnimplementedCoreWorkerServiceServer) GetObjectStatus(context.Context, *GetObjectStatusRequest) (*GetObjectStatusReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetObjectStatus not implemented")
}
func (UnimplementedCoreWorkerServiceServer) WaitForActorOutOfScope(context.Context, *WaitForActorOutOfScopeRequest) (*WaitForActorOutOfScopeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitForActorOutOfScope not implemented")
}
func (UnimplementedCoreWorkerServiceServer) PubsubLongPolling(context.Context, *PubsubLongPollingRequest) (*PubsubLongPollingReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PubsubLongPolling not implemented")
}
func (UnimplementedCoreWorkerServiceServer) PubsubCommandBatch(context.Context, *PubsubCommandBatchRequest) (*PubsubCommandBatchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PubsubCommandBatch not implemented")
}
func (UnimplementedCoreWorkerServiceServer) UpdateObjectLocationBatch(context.Context, *UpdateObjectLocationBatchRequest) (*UpdateObjectLocationBatchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateObjectLocationBatch not implemented")
}
func (UnimplementedCoreWorkerServiceServer) GetObjectLocationsOwner(context.Context, *GetObjectLocationsOwnerRequest) (*GetObjectLocationsOwnerReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetObjectLocationsOwner not implemented")
}
func (UnimplementedCoreWorkerServiceServer) KillActor(context.Context, *KillActorRequest) (*KillActorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KillActor not implemented")
}
func (UnimplementedCoreWorkerServiceServer) CancelTask(context.Context, *CancelTaskRequest) (*CancelTaskReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelTask not implemented")
}
func (UnimplementedCoreWorkerServiceServer) RemoteCancelTask(context.Context, *RemoteCancelTaskRequest) (*RemoteCancelTaskReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoteCancelTask not implemented")
}
func (UnimplementedCoreWorkerServiceServer) GetCoreWorkerStats(context.Context, *GetCoreWorkerStatsRequest) (*GetCoreWorkerStatsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCoreWorkerStats not implemented")
}
func (UnimplementedCoreWorkerServiceServer) LocalGC(context.Context, *LocalGCRequest) (*LocalGCReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LocalGC not implemented")
}
func (UnimplementedCoreWorkerServiceServer) SpillObjects(context.Context, *SpillObjectsRequest) (*SpillObjectsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpillObjects not implemented")
}
func (UnimplementedCoreWorkerServiceServer) RestoreSpilledObjects(context.Context, *RestoreSpilledObjectsRequest) (*RestoreSpilledObjectsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestoreSpilledObjects not implemented")
}
func (UnimplementedCoreWorkerServiceServer) DeleteSpilledObjects(context.Context, *DeleteSpilledObjectsRequest) (*DeleteSpilledObjectsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSpilledObjects not implemented")
}
func (UnimplementedCoreWorkerServiceServer) PlasmaObjectReady(context.Context, *PlasmaObjectReadyRequest) (*PlasmaObjectReadyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlasmaObjectReady not implemented")
}
func (UnimplementedCoreWorkerServiceServer) Exit(context.Context, *ExitRequest) (*ExitReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exit not implemented")
}
func (UnimplementedCoreWorkerServiceServer) AssignObjectOwner(context.Context, *AssignObjectOwnerRequest) (*AssignObjectOwnerReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssignObjectOwner not implemented")
}

// UnsafeCoreWorkerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CoreWorkerServiceServer will
// result in compilation errors.
type UnsafeCoreWorkerServiceServer interface {
	mustEmbedUnimplementedCoreWorkerServiceServer()
}

func RegisterCoreWorkerServiceServer(s grpc.ServiceRegistrar, srv CoreWorkerServiceServer) {
	s.RegisterService(&CoreWorkerService_ServiceDesc, srv)
}

func _CoreWorkerService_PushTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreWorkerServiceServer).PushTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.CoreWorkerService/PushTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreWorkerServiceServer).PushTask(ctx, req.(*PushTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreWorkerService_DirectActorCallArgWaitComplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DirectActorCallArgWaitCompleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreWorkerServiceServer).DirectActorCallArgWaitComplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.CoreWorkerService/DirectActorCallArgWaitComplete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreWorkerServiceServer).DirectActorCallArgWaitComplete(ctx, req.(*DirectActorCallArgWaitCompleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreWorkerService_GetObjectStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetObjectStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreWorkerServiceServer).GetObjectStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.CoreWorkerService/GetObjectStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreWorkerServiceServer).GetObjectStatus(ctx, req.(*GetObjectStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreWorkerService_WaitForActorOutOfScope_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitForActorOutOfScopeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreWorkerServiceServer).WaitForActorOutOfScope(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.CoreWorkerService/WaitForActorOutOfScope",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreWorkerServiceServer).WaitForActorOutOfScope(ctx, req.(*WaitForActorOutOfScopeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreWorkerService_PubsubLongPolling_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PubsubLongPollingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreWorkerServiceServer).PubsubLongPolling(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.CoreWorkerService/PubsubLongPolling",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreWorkerServiceServer).PubsubLongPolling(ctx, req.(*PubsubLongPollingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreWorkerService_PubsubCommandBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PubsubCommandBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreWorkerServiceServer).PubsubCommandBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.CoreWorkerService/PubsubCommandBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreWorkerServiceServer).PubsubCommandBatch(ctx, req.(*PubsubCommandBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreWorkerService_UpdateObjectLocationBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateObjectLocationBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreWorkerServiceServer).UpdateObjectLocationBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.CoreWorkerService/UpdateObjectLocationBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreWorkerServiceServer).UpdateObjectLocationBatch(ctx, req.(*UpdateObjectLocationBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreWorkerService_GetObjectLocationsOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetObjectLocationsOwnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreWorkerServiceServer).GetObjectLocationsOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.CoreWorkerService/GetObjectLocationsOwner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreWorkerServiceServer).GetObjectLocationsOwner(ctx, req.(*GetObjectLocationsOwnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreWorkerService_KillActor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KillActorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreWorkerServiceServer).KillActor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.CoreWorkerService/KillActor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreWorkerServiceServer).KillActor(ctx, req.(*KillActorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreWorkerService_CancelTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreWorkerServiceServer).CancelTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.CoreWorkerService/CancelTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreWorkerServiceServer).CancelTask(ctx, req.(*CancelTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreWorkerService_RemoteCancelTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoteCancelTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreWorkerServiceServer).RemoteCancelTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.CoreWorkerService/RemoteCancelTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreWorkerServiceServer).RemoteCancelTask(ctx, req.(*RemoteCancelTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreWorkerService_GetCoreWorkerStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCoreWorkerStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreWorkerServiceServer).GetCoreWorkerStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.CoreWorkerService/GetCoreWorkerStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreWorkerServiceServer).GetCoreWorkerStats(ctx, req.(*GetCoreWorkerStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreWorkerService_LocalGC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocalGCRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreWorkerServiceServer).LocalGC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.CoreWorkerService/LocalGC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreWorkerServiceServer).LocalGC(ctx, req.(*LocalGCRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreWorkerService_SpillObjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpillObjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreWorkerServiceServer).SpillObjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.CoreWorkerService/SpillObjects",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreWorkerServiceServer).SpillObjects(ctx, req.(*SpillObjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreWorkerService_RestoreSpilledObjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreSpilledObjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreWorkerServiceServer).RestoreSpilledObjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.CoreWorkerService/RestoreSpilledObjects",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreWorkerServiceServer).RestoreSpilledObjects(ctx, req.(*RestoreSpilledObjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreWorkerService_DeleteSpilledObjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSpilledObjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreWorkerServiceServer).DeleteSpilledObjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.CoreWorkerService/DeleteSpilledObjects",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreWorkerServiceServer).DeleteSpilledObjects(ctx, req.(*DeleteSpilledObjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreWorkerService_PlasmaObjectReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlasmaObjectReadyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreWorkerServiceServer).PlasmaObjectReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.CoreWorkerService/PlasmaObjectReady",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreWorkerServiceServer).PlasmaObjectReady(ctx, req.(*PlasmaObjectReadyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreWorkerService_Exit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreWorkerServiceServer).Exit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.CoreWorkerService/Exit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreWorkerServiceServer).Exit(ctx, req.(*ExitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreWorkerService_AssignObjectOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignObjectOwnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreWorkerServiceServer).AssignObjectOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.CoreWorkerService/AssignObjectOwner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreWorkerServiceServer).AssignObjectOwner(ctx, req.(*AssignObjectOwnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CoreWorkerService_ServiceDesc is the grpc.ServiceDesc for CoreWorkerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CoreWorkerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ray.rpc.CoreWorkerService",
	HandlerType: (*CoreWorkerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PushTask",
			Handler:    _CoreWorkerService_PushTask_Handler,
		},
		{
			MethodName: "DirectActorCallArgWaitComplete",
			Handler:    _CoreWorkerService_DirectActorCallArgWaitComplete_Handler,
		},
		{
			MethodName: "GetObjectStatus",
			Handler:    _CoreWorkerService_GetObjectStatus_Handler,
		},
		{
			MethodName: "WaitForActorOutOfScope",
			Handler:    _CoreWorkerService_WaitForActorOutOfScope_Handler,
		},
		{
			MethodName: "PubsubLongPolling",
			Handler:    _CoreWorkerService_PubsubLongPolling_Handler,
		},
		{
			MethodName: "PubsubCommandBatch",
			Handler:    _CoreWorkerService_PubsubCommandBatch_Handler,
		},
		{
			MethodName: "UpdateObjectLocationBatch",
			Handler:    _CoreWorkerService_UpdateObjectLocationBatch_Handler,
		},
		{
			MethodName: "GetObjectLocationsOwner",
			Handler:    _CoreWorkerService_GetObjectLocationsOwner_Handler,
		},
		{
			MethodName: "KillActor",
			Handler:    _CoreWorkerService_KillActor_Handler,
		},
		{
			MethodName: "CancelTask",
			Handler:    _CoreWorkerService_CancelTask_Handler,
		},
		{
			MethodName: "RemoteCancelTask",
			Handler:    _CoreWorkerService_RemoteCancelTask_Handler,
		},
		{
			MethodName: "GetCoreWorkerStats",
			Handler:    _CoreWorkerService_GetCoreWorkerStats_Handler,
		},
		{
			MethodName: "LocalGC",
			Handler:    _CoreWorkerService_LocalGC_Handler,
		},
		{
			MethodName: "SpillObjects",
			Handler:    _CoreWorkerService_SpillObjects_Handler,
		},
		{
			MethodName: "RestoreSpilledObjects",
			Handler:    _CoreWorkerService_RestoreSpilledObjects_Handler,
		},
		{
			MethodName: "DeleteSpilledObjects",
			Handler:    _CoreWorkerService_DeleteSpilledObjects_Handler,
		},
		{
			MethodName: "PlasmaObjectReady",
			Handler:    _CoreWorkerService_PlasmaObjectReady_Handler,
		},
		{
			MethodName: "Exit",
			Handler:    _CoreWorkerService_Exit_Handler,
		},
		{
			MethodName: "AssignObjectOwner",
			Handler:    _CoreWorkerService_AssignObjectOwner_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/ray/protobuf/core_worker.proto",
}
