// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: src/ray/protobuf/ray_client.proto

package protobuf

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// RayletDriverClient is the client API for RayletDriver service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RayletDriverClient interface {
	Init(ctx context.Context, in *InitRequest, opts ...grpc.CallOption) (*InitResponse, error)
	PrepRuntimeEnv(ctx context.Context, in *PrepRuntimeEnvRequest, opts ...grpc.CallOption) (*PrepRuntimeEnvResponse, error)
	GetObject(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (RayletDriver_GetObjectClient, error)
	PutObject(ctx context.Context, in *PutRequest, opts ...grpc.CallOption) (*PutResponse, error)
	WaitObject(ctx context.Context, in *WaitRequest, opts ...grpc.CallOption) (*WaitResponse, error)
	Schedule(ctx context.Context, in *ClientTask, opts ...grpc.CallOption) (*ClientTaskTicket, error)
	Terminate(ctx context.Context, in *TerminateRequest, opts ...grpc.CallOption) (*TerminateResponse, error)
	ClusterInfo(ctx context.Context, in *ClusterInfoRequest, opts ...grpc.CallOption) (*ClusterInfoResponse, error)
	KVGet(ctx context.Context, in *KVGetRequest, opts ...grpc.CallOption) (*KVGetResponse, error)
	KVPut(ctx context.Context, in *KVPutRequest, opts ...grpc.CallOption) (*KVPutResponse, error)
	KVDel(ctx context.Context, in *KVDelRequest, opts ...grpc.CallOption) (*KVDelResponse, error)
	KVList(ctx context.Context, in *KVListRequest, opts ...grpc.CallOption) (*KVListResponse, error)
	KVExists(ctx context.Context, in *KVExistsRequest, opts ...grpc.CallOption) (*KVExistsResponse, error)
	ListNamedActors(ctx context.Context, in *ClientListNamedActorsRequest, opts ...grpc.CallOption) (*ClientListNamedActorsResponse, error)
}

type rayletDriverClient struct {
	cc grpc.ClientConnInterface
}

func NewRayletDriverClient(cc grpc.ClientConnInterface) RayletDriverClient {
	return &rayletDriverClient{cc}
}

func (c *rayletDriverClient) Init(ctx context.Context, in *InitRequest, opts ...grpc.CallOption) (*InitResponse, error) {
	out := new(InitResponse)
	err := c.cc.Invoke(ctx, "/ray.rpc.RayletDriver/Init", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rayletDriverClient) PrepRuntimeEnv(ctx context.Context, in *PrepRuntimeEnvRequest, opts ...grpc.CallOption) (*PrepRuntimeEnvResponse, error) {
	out := new(PrepRuntimeEnvResponse)
	err := c.cc.Invoke(ctx, "/ray.rpc.RayletDriver/PrepRuntimeEnv", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rayletDriverClient) GetObject(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (RayletDriver_GetObjectClient, error) {
	stream, err := c.cc.NewStream(ctx, &RayletDriver_ServiceDesc.Streams[0], "/ray.rpc.RayletDriver/GetObject", opts...)
	if err != nil {
		return nil, err
	}
	x := &rayletDriverGetObjectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RayletDriver_GetObjectClient interface {
	Recv() (*GetResponse, error)
	grpc.ClientStream
}

type rayletDriverGetObjectClient struct {
	grpc.ClientStream
}

func (x *rayletDriverGetObjectClient) Recv() (*GetResponse, error) {
	m := new(GetResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rayletDriverClient) PutObject(ctx context.Context, in *PutRequest, opts ...grpc.CallOption) (*PutResponse, error) {
	out := new(PutResponse)
	err := c.cc.Invoke(ctx, "/ray.rpc.RayletDriver/PutObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rayletDriverClient) WaitObject(ctx context.Context, in *WaitRequest, opts ...grpc.CallOption) (*WaitResponse, error) {
	out := new(WaitResponse)
	err := c.cc.Invoke(ctx, "/ray.rpc.RayletDriver/WaitObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rayletDriverClient) Schedule(ctx context.Context, in *ClientTask, opts ...grpc.CallOption) (*ClientTaskTicket, error) {
	out := new(ClientTaskTicket)
	err := c.cc.Invoke(ctx, "/ray.rpc.RayletDriver/Schedule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rayletDriverClient) Terminate(ctx context.Context, in *TerminateRequest, opts ...grpc.CallOption) (*TerminateResponse, error) {
	out := new(TerminateResponse)
	err := c.cc.Invoke(ctx, "/ray.rpc.RayletDriver/Terminate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rayletDriverClient) ClusterInfo(ctx context.Context, in *ClusterInfoRequest, opts ...grpc.CallOption) (*ClusterInfoResponse, error) {
	out := new(ClusterInfoResponse)
	err := c.cc.Invoke(ctx, "/ray.rpc.RayletDriver/ClusterInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rayletDriverClient) KVGet(ctx context.Context, in *KVGetRequest, opts ...grpc.CallOption) (*KVGetResponse, error) {
	out := new(KVGetResponse)
	err := c.cc.Invoke(ctx, "/ray.rpc.RayletDriver/KVGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rayletDriverClient) KVPut(ctx context.Context, in *KVPutRequest, opts ...grpc.CallOption) (*KVPutResponse, error) {
	out := new(KVPutResponse)
	err := c.cc.Invoke(ctx, "/ray.rpc.RayletDriver/KVPut", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rayletDriverClient) KVDel(ctx context.Context, in *KVDelRequest, opts ...grpc.CallOption) (*KVDelResponse, error) {
	out := new(KVDelResponse)
	err := c.cc.Invoke(ctx, "/ray.rpc.RayletDriver/KVDel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rayletDriverClient) KVList(ctx context.Context, in *KVListRequest, opts ...grpc.CallOption) (*KVListResponse, error) {
	out := new(KVListResponse)
	err := c.cc.Invoke(ctx, "/ray.rpc.RayletDriver/KVList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rayletDriverClient) KVExists(ctx context.Context, in *KVExistsRequest, opts ...grpc.CallOption) (*KVExistsResponse, error) {
	out := new(KVExistsResponse)
	err := c.cc.Invoke(ctx, "/ray.rpc.RayletDriver/KVExists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rayletDriverClient) ListNamedActors(ctx context.Context, in *ClientListNamedActorsRequest, opts ...grpc.CallOption) (*ClientListNamedActorsResponse, error) {
	out := new(ClientListNamedActorsResponse)
	err := c.cc.Invoke(ctx, "/ray.rpc.RayletDriver/ListNamedActors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RayletDriverServer is the server API for RayletDriver service.
// All implementations should embed UnimplementedRayletDriverServer
// for forward compatibility
type RayletDriverServer interface {
	Init(context.Context, *InitRequest) (*InitResponse, error)
	PrepRuntimeEnv(context.Context, *PrepRuntimeEnvRequest) (*PrepRuntimeEnvResponse, error)
	GetObject(*GetRequest, RayletDriver_GetObjectServer) error
	PutObject(context.Context, *PutRequest) (*PutResponse, error)
	WaitObject(context.Context, *WaitRequest) (*WaitResponse, error)
	Schedule(context.Context, *ClientTask) (*ClientTaskTicket, error)
	Terminate(context.Context, *TerminateRequest) (*TerminateResponse, error)
	ClusterInfo(context.Context, *ClusterInfoRequest) (*ClusterInfoResponse, error)
	KVGet(context.Context, *KVGetRequest) (*KVGetResponse, error)
	KVPut(context.Context, *KVPutRequest) (*KVPutResponse, error)
	KVDel(context.Context, *KVDelRequest) (*KVDelResponse, error)
	KVList(context.Context, *KVListRequest) (*KVListResponse, error)
	KVExists(context.Context, *KVExistsRequest) (*KVExistsResponse, error)
	ListNamedActors(context.Context, *ClientListNamedActorsRequest) (*ClientListNamedActorsResponse, error)
}

// UnimplementedRayletDriverServer should be embedded to have forward compatible implementations.
type UnimplementedRayletDriverServer struct {
}

func (UnimplementedRayletDriverServer) Init(context.Context, *InitRequest) (*InitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Init not implemented")
}
func (UnimplementedRayletDriverServer) PrepRuntimeEnv(context.Context, *PrepRuntimeEnvRequest) (*PrepRuntimeEnvResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepRuntimeEnv not implemented")
}
func (UnimplementedRayletDriverServer) GetObject(*GetRequest, RayletDriver_GetObjectServer) error {
	return status.Errorf(codes.Unimplemented, "method GetObject not implemented")
}
func (UnimplementedRayletDriverServer) PutObject(context.Context, *PutRequest) (*PutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutObject not implemented")
}
func (UnimplementedRayletDriverServer) WaitObject(context.Context, *WaitRequest) (*WaitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitObject not implemented")
}
func (UnimplementedRayletDriverServer) Schedule(context.Context, *ClientTask) (*ClientTaskTicket, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Schedule not implemented")
}
func (UnimplementedRayletDriverServer) Terminate(context.Context, *TerminateRequest) (*TerminateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Terminate not implemented")
}
func (UnimplementedRayletDriverServer) ClusterInfo(context.Context, *ClusterInfoRequest) (*ClusterInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClusterInfo not implemented")
}
func (UnimplementedRayletDriverServer) KVGet(context.Context, *KVGetRequest) (*KVGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KVGet not implemented")
}
func (UnimplementedRayletDriverServer) KVPut(context.Context, *KVPutRequest) (*KVPutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KVPut not implemented")
}
func (UnimplementedRayletDriverServer) KVDel(context.Context, *KVDelRequest) (*KVDelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KVDel not implemented")
}
func (UnimplementedRayletDriverServer) KVList(context.Context, *KVListRequest) (*KVListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KVList not implemented")
}
func (UnimplementedRayletDriverServer) KVExists(context.Context, *KVExistsRequest) (*KVExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KVExists not implemented")
}
func (UnimplementedRayletDriverServer) ListNamedActors(context.Context, *ClientListNamedActorsRequest) (*ClientListNamedActorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNamedActors not implemented")
}

// UnsafeRayletDriverServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RayletDriverServer will
// result in compilation errors.
type UnsafeRayletDriverServer interface {
	mustEmbedUnimplementedRayletDriverServer()
}

func RegisterRayletDriverServer(s grpc.ServiceRegistrar, srv RayletDriverServer) {
	s.RegisterService(&RayletDriver_ServiceDesc, srv)
}

func _RayletDriver_Init_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RayletDriverServer).Init(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.RayletDriver/Init",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RayletDriverServer).Init(ctx, req.(*InitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RayletDriver_PrepRuntimeEnv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepRuntimeEnvRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RayletDriverServer).PrepRuntimeEnv(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.RayletDriver/PrepRuntimeEnv",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RayletDriverServer).PrepRuntimeEnv(ctx, req.(*PrepRuntimeEnvRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RayletDriver_GetObject_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RayletDriverServer).GetObject(m, &rayletDriverGetObjectServer{stream})
}

type RayletDriver_GetObjectServer interface {
	Send(*GetResponse) error
	grpc.ServerStream
}

type rayletDriverGetObjectServer struct {
	grpc.ServerStream
}

func (x *rayletDriverGetObjectServer) Send(m *GetResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _RayletDriver_PutObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RayletDriverServer).PutObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.RayletDriver/PutObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RayletDriverServer).PutObject(ctx, req.(*PutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RayletDriver_WaitObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RayletDriverServer).WaitObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.RayletDriver/WaitObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RayletDriverServer).WaitObject(ctx, req.(*WaitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RayletDriver_Schedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientTask)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RayletDriverServer).Schedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.RayletDriver/Schedule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RayletDriverServer).Schedule(ctx, req.(*ClientTask))
	}
	return interceptor(ctx, in, info, handler)
}

func _RayletDriver_Terminate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RayletDriverServer).Terminate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.RayletDriver/Terminate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RayletDriverServer).Terminate(ctx, req.(*TerminateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RayletDriver_ClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RayletDriverServer).ClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.RayletDriver/ClusterInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RayletDriverServer).ClusterInfo(ctx, req.(*ClusterInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RayletDriver_KVGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KVGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RayletDriverServer).KVGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.RayletDriver/KVGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RayletDriverServer).KVGet(ctx, req.(*KVGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RayletDriver_KVPut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KVPutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RayletDriverServer).KVPut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.RayletDriver/KVPut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RayletDriverServer).KVPut(ctx, req.(*KVPutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RayletDriver_KVDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KVDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RayletDriverServer).KVDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.RayletDriver/KVDel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RayletDriverServer).KVDel(ctx, req.(*KVDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RayletDriver_KVList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KVListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RayletDriverServer).KVList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.RayletDriver/KVList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RayletDriverServer).KVList(ctx, req.(*KVListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RayletDriver_KVExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KVExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RayletDriverServer).KVExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.RayletDriver/KVExists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RayletDriverServer).KVExists(ctx, req.(*KVExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RayletDriver_ListNamedActors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientListNamedActorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RayletDriverServer).ListNamedActors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.RayletDriver/ListNamedActors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RayletDriverServer).ListNamedActors(ctx, req.(*ClientListNamedActorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RayletDriver_ServiceDesc is the grpc.ServiceDesc for RayletDriver service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RayletDriver_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ray.rpc.RayletDriver",
	HandlerType: (*RayletDriverServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Init",
			Handler:    _RayletDriver_Init_Handler,
		},
		{
			MethodName: "PrepRuntimeEnv",
			Handler:    _RayletDriver_PrepRuntimeEnv_Handler,
		},
		{
			MethodName: "PutObject",
			Handler:    _RayletDriver_PutObject_Handler,
		},
		{
			MethodName: "WaitObject",
			Handler:    _RayletDriver_WaitObject_Handler,
		},
		{
			MethodName: "Schedule",
			Handler:    _RayletDriver_Schedule_Handler,
		},
		{
			MethodName: "Terminate",
			Handler:    _RayletDriver_Terminate_Handler,
		},
		{
			MethodName: "ClusterInfo",
			Handler:    _RayletDriver_ClusterInfo_Handler,
		},
		{
			MethodName: "KVGet",
			Handler:    _RayletDriver_KVGet_Handler,
		},
		{
			MethodName: "KVPut",
			Handler:    _RayletDriver_KVPut_Handler,
		},
		{
			MethodName: "KVDel",
			Handler:    _RayletDriver_KVDel_Handler,
		},
		{
			MethodName: "KVList",
			Handler:    _RayletDriver_KVList_Handler,
		},
		{
			MethodName: "KVExists",
			Handler:    _RayletDriver_KVExists_Handler,
		},
		{
			MethodName: "ListNamedActors",
			Handler:    _RayletDriver_ListNamedActors_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetObject",
			Handler:       _RayletDriver_GetObject_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "src/ray/protobuf/ray_client.proto",
}

// RayletDataStreamerClient is the client API for RayletDataStreamer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RayletDataStreamerClient interface {
	Datapath(ctx context.Context, opts ...grpc.CallOption) (RayletDataStreamer_DatapathClient, error)
}

type rayletDataStreamerClient struct {
	cc grpc.ClientConnInterface
}

func NewRayletDataStreamerClient(cc grpc.ClientConnInterface) RayletDataStreamerClient {
	return &rayletDataStreamerClient{cc}
}

func (c *rayletDataStreamerClient) Datapath(ctx context.Context, opts ...grpc.CallOption) (RayletDataStreamer_DatapathClient, error) {
	stream, err := c.cc.NewStream(ctx, &RayletDataStreamer_ServiceDesc.Streams[0], "/ray.rpc.RayletDataStreamer/Datapath", opts...)
	if err != nil {
		return nil, err
	}
	x := &rayletDataStreamerDatapathClient{stream}
	return x, nil
}

type RayletDataStreamer_DatapathClient interface {
	Send(*DataRequest) error
	Recv() (*DataResponse, error)
	grpc.ClientStream
}

type rayletDataStreamerDatapathClient struct {
	grpc.ClientStream
}

func (x *rayletDataStreamerDatapathClient) Send(m *DataRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *rayletDataStreamerDatapathClient) Recv() (*DataResponse, error) {
	m := new(DataResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RayletDataStreamerServer is the server API for RayletDataStreamer service.
// All implementations should embed UnimplementedRayletDataStreamerServer
// for forward compatibility
type RayletDataStreamerServer interface {
	Datapath(RayletDataStreamer_DatapathServer) error
}

// UnimplementedRayletDataStreamerServer should be embedded to have forward compatible implementations.
type UnimplementedRayletDataStreamerServer struct {
}

func (UnimplementedRayletDataStreamerServer) Datapath(RayletDataStreamer_DatapathServer) error {
	return status.Errorf(codes.Unimplemented, "method Datapath not implemented")
}

// UnsafeRayletDataStreamerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RayletDataStreamerServer will
// result in compilation errors.
type UnsafeRayletDataStreamerServer interface {
	mustEmbedUnimplementedRayletDataStreamerServer()
}

func RegisterRayletDataStreamerServer(s grpc.ServiceRegistrar, srv RayletDataStreamerServer) {
	s.RegisterService(&RayletDataStreamer_ServiceDesc, srv)
}

func _RayletDataStreamer_Datapath_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RayletDataStreamerServer).Datapath(&rayletDataStreamerDatapathServer{stream})
}

type RayletDataStreamer_DatapathServer interface {
	Send(*DataResponse) error
	Recv() (*DataRequest, error)
	grpc.ServerStream
}

type rayletDataStreamerDatapathServer struct {
	grpc.ServerStream
}

func (x *rayletDataStreamerDatapathServer) Send(m *DataResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *rayletDataStreamerDatapathServer) Recv() (*DataRequest, error) {
	m := new(DataRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RayletDataStreamer_ServiceDesc is the grpc.ServiceDesc for RayletDataStreamer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RayletDataStreamer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ray.rpc.RayletDataStreamer",
	HandlerType: (*RayletDataStreamerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Datapath",
			Handler:       _RayletDataStreamer_Datapath_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "src/ray/protobuf/ray_client.proto",
}

// RayletLogStreamerClient is the client API for RayletLogStreamer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RayletLogStreamerClient interface {
	Logstream(ctx context.Context, opts ...grpc.CallOption) (RayletLogStreamer_LogstreamClient, error)
}

type rayletLogStreamerClient struct {
	cc grpc.ClientConnInterface
}

func NewRayletLogStreamerClient(cc grpc.ClientConnInterface) RayletLogStreamerClient {
	return &rayletLogStreamerClient{cc}
}

func (c *rayletLogStreamerClient) Logstream(ctx context.Context, opts ...grpc.CallOption) (RayletLogStreamer_LogstreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &RayletLogStreamer_ServiceDesc.Streams[0], "/ray.rpc.RayletLogStreamer/Logstream", opts...)
	if err != nil {
		return nil, err
	}
	x := &rayletLogStreamerLogstreamClient{stream}
	return x, nil
}

type RayletLogStreamer_LogstreamClient interface {
	Send(*LogSettingsRequest) error
	Recv() (*LogData, error)
	grpc.ClientStream
}

type rayletLogStreamerLogstreamClient struct {
	grpc.ClientStream
}

func (x *rayletLogStreamerLogstreamClient) Send(m *LogSettingsRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *rayletLogStreamerLogstreamClient) Recv() (*LogData, error) {
	m := new(LogData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RayletLogStreamerServer is the server API for RayletLogStreamer service.
// All implementations should embed UnimplementedRayletLogStreamerServer
// for forward compatibility
type RayletLogStreamerServer interface {
	Logstream(RayletLogStreamer_LogstreamServer) error
}

// UnimplementedRayletLogStreamerServer should be embedded to have forward compatible implementations.
type UnimplementedRayletLogStreamerServer struct {
}

func (UnimplementedRayletLogStreamerServer) Logstream(RayletLogStreamer_LogstreamServer) error {
	return status.Errorf(codes.Unimplemented, "method Logstream not implemented")
}

// UnsafeRayletLogStreamerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RayletLogStreamerServer will
// result in compilation errors.
type UnsafeRayletLogStreamerServer interface {
	mustEmbedUnimplementedRayletLogStreamerServer()
}

func RegisterRayletLogStreamerServer(s grpc.ServiceRegistrar, srv RayletLogStreamerServer) {
	s.RegisterService(&RayletLogStreamer_ServiceDesc, srv)
}

func _RayletLogStreamer_Logstream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RayletLogStreamerServer).Logstream(&rayletLogStreamerLogstreamServer{stream})
}

type RayletLogStreamer_LogstreamServer interface {
	Send(*LogData) error
	Recv() (*LogSettingsRequest, error)
	grpc.ServerStream
}

type rayletLogStreamerLogstreamServer struct {
	grpc.ServerStream
}

func (x *rayletLogStreamerLogstreamServer) Send(m *LogData) error {
	return x.ServerStream.SendMsg(m)
}

func (x *rayletLogStreamerLogstreamServer) Recv() (*LogSettingsRequest, error) {
	m := new(LogSettingsRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RayletLogStreamer_ServiceDesc is the grpc.ServiceDesc for RayletLogStreamer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RayletLogStreamer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ray.rpc.RayletLogStreamer",
	HandlerType: (*RayletLogStreamerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Logstream",
			Handler:       _RayletLogStreamer_Logstream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "src/ray/protobuf/ray_client.proto",
}
