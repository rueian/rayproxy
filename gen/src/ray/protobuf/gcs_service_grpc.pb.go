// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: src/ray/protobuf/gcs_service.proto

package protobuf

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// JobInfoGcsServiceClient is the client API for JobInfoGcsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type JobInfoGcsServiceClient interface {
	// Add job to GCS Service.
	AddJob(ctx context.Context, in *AddJobRequest, opts ...grpc.CallOption) (*AddJobReply, error)
	// Mark job as finished to GCS Service.
	MarkJobFinished(ctx context.Context, in *MarkJobFinishedRequest, opts ...grpc.CallOption) (*MarkJobFinishedReply, error)
	// Get information of all jobs from GCS Service.
	GetAllJobInfo(ctx context.Context, in *GetAllJobInfoRequest, opts ...grpc.CallOption) (*GetAllJobInfoReply, error)
	// Report job error.
	ReportJobError(ctx context.Context, in *ReportJobErrorRequest, opts ...grpc.CallOption) (*ReportJobErrorReply, error)
	// Get next job id.
	GetNextJobID(ctx context.Context, in *GetNextJobIDRequest, opts ...grpc.CallOption) (*GetNextJobIDReply, error)
}

type jobInfoGcsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewJobInfoGcsServiceClient(cc grpc.ClientConnInterface) JobInfoGcsServiceClient {
	return &jobInfoGcsServiceClient{cc}
}

func (c *jobInfoGcsServiceClient) AddJob(ctx context.Context, in *AddJobRequest, opts ...grpc.CallOption) (*AddJobReply, error) {
	out := new(AddJobReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.JobInfoGcsService/AddJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInfoGcsServiceClient) MarkJobFinished(ctx context.Context, in *MarkJobFinishedRequest, opts ...grpc.CallOption) (*MarkJobFinishedReply, error) {
	out := new(MarkJobFinishedReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.JobInfoGcsService/MarkJobFinished", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInfoGcsServiceClient) GetAllJobInfo(ctx context.Context, in *GetAllJobInfoRequest, opts ...grpc.CallOption) (*GetAllJobInfoReply, error) {
	out := new(GetAllJobInfoReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.JobInfoGcsService/GetAllJobInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInfoGcsServiceClient) ReportJobError(ctx context.Context, in *ReportJobErrorRequest, opts ...grpc.CallOption) (*ReportJobErrorReply, error) {
	out := new(ReportJobErrorReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.JobInfoGcsService/ReportJobError", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInfoGcsServiceClient) GetNextJobID(ctx context.Context, in *GetNextJobIDRequest, opts ...grpc.CallOption) (*GetNextJobIDReply, error) {
	out := new(GetNextJobIDReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.JobInfoGcsService/GetNextJobID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JobInfoGcsServiceServer is the server API for JobInfoGcsService service.
// All implementations should embed UnimplementedJobInfoGcsServiceServer
// for forward compatibility
type JobInfoGcsServiceServer interface {
	// Add job to GCS Service.
	AddJob(context.Context, *AddJobRequest) (*AddJobReply, error)
	// Mark job as finished to GCS Service.
	MarkJobFinished(context.Context, *MarkJobFinishedRequest) (*MarkJobFinishedReply, error)
	// Get information of all jobs from GCS Service.
	GetAllJobInfo(context.Context, *GetAllJobInfoRequest) (*GetAllJobInfoReply, error)
	// Report job error.
	ReportJobError(context.Context, *ReportJobErrorRequest) (*ReportJobErrorReply, error)
	// Get next job id.
	GetNextJobID(context.Context, *GetNextJobIDRequest) (*GetNextJobIDReply, error)
}

// UnimplementedJobInfoGcsServiceServer should be embedded to have forward compatible implementations.
type UnimplementedJobInfoGcsServiceServer struct {
}

func (UnimplementedJobInfoGcsServiceServer) AddJob(context.Context, *AddJobRequest) (*AddJobReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddJob not implemented")
}
func (UnimplementedJobInfoGcsServiceServer) MarkJobFinished(context.Context, *MarkJobFinishedRequest) (*MarkJobFinishedReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkJobFinished not implemented")
}
func (UnimplementedJobInfoGcsServiceServer) GetAllJobInfo(context.Context, *GetAllJobInfoRequest) (*GetAllJobInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllJobInfo not implemented")
}
func (UnimplementedJobInfoGcsServiceServer) ReportJobError(context.Context, *ReportJobErrorRequest) (*ReportJobErrorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportJobError not implemented")
}
func (UnimplementedJobInfoGcsServiceServer) GetNextJobID(context.Context, *GetNextJobIDRequest) (*GetNextJobIDReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNextJobID not implemented")
}

// UnsafeJobInfoGcsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JobInfoGcsServiceServer will
// result in compilation errors.
type UnsafeJobInfoGcsServiceServer interface {
	mustEmbedUnimplementedJobInfoGcsServiceServer()
}

func RegisterJobInfoGcsServiceServer(s grpc.ServiceRegistrar, srv JobInfoGcsServiceServer) {
	s.RegisterService(&JobInfoGcsService_ServiceDesc, srv)
}

func _JobInfoGcsService_AddJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInfoGcsServiceServer).AddJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.JobInfoGcsService/AddJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInfoGcsServiceServer).AddJob(ctx, req.(*AddJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInfoGcsService_MarkJobFinished_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkJobFinishedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInfoGcsServiceServer).MarkJobFinished(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.JobInfoGcsService/MarkJobFinished",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInfoGcsServiceServer).MarkJobFinished(ctx, req.(*MarkJobFinishedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInfoGcsService_GetAllJobInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllJobInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInfoGcsServiceServer).GetAllJobInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.JobInfoGcsService/GetAllJobInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInfoGcsServiceServer).GetAllJobInfo(ctx, req.(*GetAllJobInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInfoGcsService_ReportJobError_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportJobErrorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInfoGcsServiceServer).ReportJobError(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.JobInfoGcsService/ReportJobError",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInfoGcsServiceServer).ReportJobError(ctx, req.(*ReportJobErrorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInfoGcsService_GetNextJobID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNextJobIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInfoGcsServiceServer).GetNextJobID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.JobInfoGcsService/GetNextJobID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInfoGcsServiceServer).GetNextJobID(ctx, req.(*GetNextJobIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// JobInfoGcsService_ServiceDesc is the grpc.ServiceDesc for JobInfoGcsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var JobInfoGcsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ray.rpc.JobInfoGcsService",
	HandlerType: (*JobInfoGcsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddJob",
			Handler:    _JobInfoGcsService_AddJob_Handler,
		},
		{
			MethodName: "MarkJobFinished",
			Handler:    _JobInfoGcsService_MarkJobFinished_Handler,
		},
		{
			MethodName: "GetAllJobInfo",
			Handler:    _JobInfoGcsService_GetAllJobInfo_Handler,
		},
		{
			MethodName: "ReportJobError",
			Handler:    _JobInfoGcsService_ReportJobError_Handler,
		},
		{
			MethodName: "GetNextJobID",
			Handler:    _JobInfoGcsService_GetNextJobID_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/ray/protobuf/gcs_service.proto",
}

// ActorInfoGcsServiceClient is the client API for ActorInfoGcsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ActorInfoGcsServiceClient interface {
	// Register actor to gcs service.
	RegisterActor(ctx context.Context, in *RegisterActorRequest, opts ...grpc.CallOption) (*RegisterActorReply, error)
	// Create actor which local dependencies are resolved.
	CreateActor(ctx context.Context, in *CreateActorRequest, opts ...grpc.CallOption) (*CreateActorReply, error)
	// Get actor data from GCS Service by actor id.
	GetActorInfo(ctx context.Context, in *GetActorInfoRequest, opts ...grpc.CallOption) (*GetActorInfoReply, error)
	// Get actor data from GCS Service by name.
	GetNamedActorInfo(ctx context.Context, in *GetNamedActorInfoRequest, opts ...grpc.CallOption) (*GetNamedActorInfoReply, error)
	// Get all named actor names from GCS Service.
	ListNamedActors(ctx context.Context, in *ListNamedActorsRequest, opts ...grpc.CallOption) (*ListNamedActorsReply, error)
	// Get information of all actor from GCS Service.
	GetAllActorInfo(ctx context.Context, in *GetAllActorInfoRequest, opts ...grpc.CallOption) (*GetAllActorInfoReply, error)
	// Kill actor via GCS Service.
	KillActorViaGcs(ctx context.Context, in *KillActorViaGcsRequest, opts ...grpc.CallOption) (*KillActorViaGcsReply, error)
}

type actorInfoGcsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewActorInfoGcsServiceClient(cc grpc.ClientConnInterface) ActorInfoGcsServiceClient {
	return &actorInfoGcsServiceClient{cc}
}

func (c *actorInfoGcsServiceClient) RegisterActor(ctx context.Context, in *RegisterActorRequest, opts ...grpc.CallOption) (*RegisterActorReply, error) {
	out := new(RegisterActorReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.ActorInfoGcsService/RegisterActor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actorInfoGcsServiceClient) CreateActor(ctx context.Context, in *CreateActorRequest, opts ...grpc.CallOption) (*CreateActorReply, error) {
	out := new(CreateActorReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.ActorInfoGcsService/CreateActor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actorInfoGcsServiceClient) GetActorInfo(ctx context.Context, in *GetActorInfoRequest, opts ...grpc.CallOption) (*GetActorInfoReply, error) {
	out := new(GetActorInfoReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.ActorInfoGcsService/GetActorInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actorInfoGcsServiceClient) GetNamedActorInfo(ctx context.Context, in *GetNamedActorInfoRequest, opts ...grpc.CallOption) (*GetNamedActorInfoReply, error) {
	out := new(GetNamedActorInfoReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.ActorInfoGcsService/GetNamedActorInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actorInfoGcsServiceClient) ListNamedActors(ctx context.Context, in *ListNamedActorsRequest, opts ...grpc.CallOption) (*ListNamedActorsReply, error) {
	out := new(ListNamedActorsReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.ActorInfoGcsService/ListNamedActors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actorInfoGcsServiceClient) GetAllActorInfo(ctx context.Context, in *GetAllActorInfoRequest, opts ...grpc.CallOption) (*GetAllActorInfoReply, error) {
	out := new(GetAllActorInfoReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.ActorInfoGcsService/GetAllActorInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actorInfoGcsServiceClient) KillActorViaGcs(ctx context.Context, in *KillActorViaGcsRequest, opts ...grpc.CallOption) (*KillActorViaGcsReply, error) {
	out := new(KillActorViaGcsReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.ActorInfoGcsService/KillActorViaGcs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ActorInfoGcsServiceServer is the server API for ActorInfoGcsService service.
// All implementations should embed UnimplementedActorInfoGcsServiceServer
// for forward compatibility
type ActorInfoGcsServiceServer interface {
	// Register actor to gcs service.
	RegisterActor(context.Context, *RegisterActorRequest) (*RegisterActorReply, error)
	// Create actor which local dependencies are resolved.
	CreateActor(context.Context, *CreateActorRequest) (*CreateActorReply, error)
	// Get actor data from GCS Service by actor id.
	GetActorInfo(context.Context, *GetActorInfoRequest) (*GetActorInfoReply, error)
	// Get actor data from GCS Service by name.
	GetNamedActorInfo(context.Context, *GetNamedActorInfoRequest) (*GetNamedActorInfoReply, error)
	// Get all named actor names from GCS Service.
	ListNamedActors(context.Context, *ListNamedActorsRequest) (*ListNamedActorsReply, error)
	// Get information of all actor from GCS Service.
	GetAllActorInfo(context.Context, *GetAllActorInfoRequest) (*GetAllActorInfoReply, error)
	// Kill actor via GCS Service.
	KillActorViaGcs(context.Context, *KillActorViaGcsRequest) (*KillActorViaGcsReply, error)
}

// UnimplementedActorInfoGcsServiceServer should be embedded to have forward compatible implementations.
type UnimplementedActorInfoGcsServiceServer struct {
}

func (UnimplementedActorInfoGcsServiceServer) RegisterActor(context.Context, *RegisterActorRequest) (*RegisterActorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterActor not implemented")
}
func (UnimplementedActorInfoGcsServiceServer) CreateActor(context.Context, *CreateActorRequest) (*CreateActorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateActor not implemented")
}
func (UnimplementedActorInfoGcsServiceServer) GetActorInfo(context.Context, *GetActorInfoRequest) (*GetActorInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActorInfo not implemented")
}
func (UnimplementedActorInfoGcsServiceServer) GetNamedActorInfo(context.Context, *GetNamedActorInfoRequest) (*GetNamedActorInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNamedActorInfo not implemented")
}
func (UnimplementedActorInfoGcsServiceServer) ListNamedActors(context.Context, *ListNamedActorsRequest) (*ListNamedActorsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNamedActors not implemented")
}
func (UnimplementedActorInfoGcsServiceServer) GetAllActorInfo(context.Context, *GetAllActorInfoRequest) (*GetAllActorInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllActorInfo not implemented")
}
func (UnimplementedActorInfoGcsServiceServer) KillActorViaGcs(context.Context, *KillActorViaGcsRequest) (*KillActorViaGcsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KillActorViaGcs not implemented")
}

// UnsafeActorInfoGcsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ActorInfoGcsServiceServer will
// result in compilation errors.
type UnsafeActorInfoGcsServiceServer interface {
	mustEmbedUnimplementedActorInfoGcsServiceServer()
}

func RegisterActorInfoGcsServiceServer(s grpc.ServiceRegistrar, srv ActorInfoGcsServiceServer) {
	s.RegisterService(&ActorInfoGcsService_ServiceDesc, srv)
}

func _ActorInfoGcsService_RegisterActor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterActorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActorInfoGcsServiceServer).RegisterActor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.ActorInfoGcsService/RegisterActor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActorInfoGcsServiceServer).RegisterActor(ctx, req.(*RegisterActorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActorInfoGcsService_CreateActor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateActorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActorInfoGcsServiceServer).CreateActor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.ActorInfoGcsService/CreateActor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActorInfoGcsServiceServer).CreateActor(ctx, req.(*CreateActorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActorInfoGcsService_GetActorInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActorInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActorInfoGcsServiceServer).GetActorInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.ActorInfoGcsService/GetActorInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActorInfoGcsServiceServer).GetActorInfo(ctx, req.(*GetActorInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActorInfoGcsService_GetNamedActorInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNamedActorInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActorInfoGcsServiceServer).GetNamedActorInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.ActorInfoGcsService/GetNamedActorInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActorInfoGcsServiceServer).GetNamedActorInfo(ctx, req.(*GetNamedActorInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActorInfoGcsService_ListNamedActors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNamedActorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActorInfoGcsServiceServer).ListNamedActors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.ActorInfoGcsService/ListNamedActors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActorInfoGcsServiceServer).ListNamedActors(ctx, req.(*ListNamedActorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActorInfoGcsService_GetAllActorInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllActorInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActorInfoGcsServiceServer).GetAllActorInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.ActorInfoGcsService/GetAllActorInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActorInfoGcsServiceServer).GetAllActorInfo(ctx, req.(*GetAllActorInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActorInfoGcsService_KillActorViaGcs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KillActorViaGcsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActorInfoGcsServiceServer).KillActorViaGcs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.ActorInfoGcsService/KillActorViaGcs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActorInfoGcsServiceServer).KillActorViaGcs(ctx, req.(*KillActorViaGcsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ActorInfoGcsService_ServiceDesc is the grpc.ServiceDesc for ActorInfoGcsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ActorInfoGcsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ray.rpc.ActorInfoGcsService",
	HandlerType: (*ActorInfoGcsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterActor",
			Handler:    _ActorInfoGcsService_RegisterActor_Handler,
		},
		{
			MethodName: "CreateActor",
			Handler:    _ActorInfoGcsService_CreateActor_Handler,
		},
		{
			MethodName: "GetActorInfo",
			Handler:    _ActorInfoGcsService_GetActorInfo_Handler,
		},
		{
			MethodName: "GetNamedActorInfo",
			Handler:    _ActorInfoGcsService_GetNamedActorInfo_Handler,
		},
		{
			MethodName: "ListNamedActors",
			Handler:    _ActorInfoGcsService_ListNamedActors_Handler,
		},
		{
			MethodName: "GetAllActorInfo",
			Handler:    _ActorInfoGcsService_GetAllActorInfo_Handler,
		},
		{
			MethodName: "KillActorViaGcs",
			Handler:    _ActorInfoGcsService_KillActorViaGcs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/ray/protobuf/gcs_service.proto",
}

// HeartbeatInfoGcsServiceClient is the client API for HeartbeatInfoGcsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HeartbeatInfoGcsServiceClient interface {
	// Report heartbeat of a node to GCS Service.
	ReportHeartbeat(ctx context.Context, in *ReportHeartbeatRequest, opts ...grpc.CallOption) (*ReportHeartbeatReply, error)
	// Check alive.
	CheckAlive(ctx context.Context, in *CheckAliveRequest, opts ...grpc.CallOption) (*CheckAliveReply, error)
}

type heartbeatInfoGcsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHeartbeatInfoGcsServiceClient(cc grpc.ClientConnInterface) HeartbeatInfoGcsServiceClient {
	return &heartbeatInfoGcsServiceClient{cc}
}

func (c *heartbeatInfoGcsServiceClient) ReportHeartbeat(ctx context.Context, in *ReportHeartbeatRequest, opts ...grpc.CallOption) (*ReportHeartbeatReply, error) {
	out := new(ReportHeartbeatReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.HeartbeatInfoGcsService/ReportHeartbeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *heartbeatInfoGcsServiceClient) CheckAlive(ctx context.Context, in *CheckAliveRequest, opts ...grpc.CallOption) (*CheckAliveReply, error) {
	out := new(CheckAliveReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.HeartbeatInfoGcsService/CheckAlive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HeartbeatInfoGcsServiceServer is the server API for HeartbeatInfoGcsService service.
// All implementations should embed UnimplementedHeartbeatInfoGcsServiceServer
// for forward compatibility
type HeartbeatInfoGcsServiceServer interface {
	// Report heartbeat of a node to GCS Service.
	ReportHeartbeat(context.Context, *ReportHeartbeatRequest) (*ReportHeartbeatReply, error)
	// Check alive.
	CheckAlive(context.Context, *CheckAliveRequest) (*CheckAliveReply, error)
}

// UnimplementedHeartbeatInfoGcsServiceServer should be embedded to have forward compatible implementations.
type UnimplementedHeartbeatInfoGcsServiceServer struct {
}

func (UnimplementedHeartbeatInfoGcsServiceServer) ReportHeartbeat(context.Context, *ReportHeartbeatRequest) (*ReportHeartbeatReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportHeartbeat not implemented")
}
func (UnimplementedHeartbeatInfoGcsServiceServer) CheckAlive(context.Context, *CheckAliveRequest) (*CheckAliveReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckAlive not implemented")
}

// UnsafeHeartbeatInfoGcsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HeartbeatInfoGcsServiceServer will
// result in compilation errors.
type UnsafeHeartbeatInfoGcsServiceServer interface {
	mustEmbedUnimplementedHeartbeatInfoGcsServiceServer()
}

func RegisterHeartbeatInfoGcsServiceServer(s grpc.ServiceRegistrar, srv HeartbeatInfoGcsServiceServer) {
	s.RegisterService(&HeartbeatInfoGcsService_ServiceDesc, srv)
}

func _HeartbeatInfoGcsService_ReportHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HeartbeatInfoGcsServiceServer).ReportHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.HeartbeatInfoGcsService/ReportHeartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HeartbeatInfoGcsServiceServer).ReportHeartbeat(ctx, req.(*ReportHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HeartbeatInfoGcsService_CheckAlive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckAliveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HeartbeatInfoGcsServiceServer).CheckAlive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.HeartbeatInfoGcsService/CheckAlive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HeartbeatInfoGcsServiceServer).CheckAlive(ctx, req.(*CheckAliveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HeartbeatInfoGcsService_ServiceDesc is the grpc.ServiceDesc for HeartbeatInfoGcsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HeartbeatInfoGcsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ray.rpc.HeartbeatInfoGcsService",
	HandlerType: (*HeartbeatInfoGcsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReportHeartbeat",
			Handler:    _HeartbeatInfoGcsService_ReportHeartbeat_Handler,
		},
		{
			MethodName: "CheckAlive",
			Handler:    _HeartbeatInfoGcsService_CheckAlive_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/ray/protobuf/gcs_service.proto",
}

// StatsGcsServiceClient is the client API for StatsGcsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StatsGcsServiceClient interface {
	// Add profile data to GCS Service.
	AddProfileData(ctx context.Context, in *AddProfileDataRequest, opts ...grpc.CallOption) (*AddProfileDataReply, error)
	// Get information of all profiles from GCS Service.
	GetAllProfileInfo(ctx context.Context, in *GetAllProfileInfoRequest, opts ...grpc.CallOption) (*GetAllProfileInfoReply, error)
}

type statsGcsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStatsGcsServiceClient(cc grpc.ClientConnInterface) StatsGcsServiceClient {
	return &statsGcsServiceClient{cc}
}

func (c *statsGcsServiceClient) AddProfileData(ctx context.Context, in *AddProfileDataRequest, opts ...grpc.CallOption) (*AddProfileDataReply, error) {
	out := new(AddProfileDataReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.StatsGcsService/AddProfileData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statsGcsServiceClient) GetAllProfileInfo(ctx context.Context, in *GetAllProfileInfoRequest, opts ...grpc.CallOption) (*GetAllProfileInfoReply, error) {
	out := new(GetAllProfileInfoReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.StatsGcsService/GetAllProfileInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StatsGcsServiceServer is the server API for StatsGcsService service.
// All implementations should embed UnimplementedStatsGcsServiceServer
// for forward compatibility
type StatsGcsServiceServer interface {
	// Add profile data to GCS Service.
	AddProfileData(context.Context, *AddProfileDataRequest) (*AddProfileDataReply, error)
	// Get information of all profiles from GCS Service.
	GetAllProfileInfo(context.Context, *GetAllProfileInfoRequest) (*GetAllProfileInfoReply, error)
}

// UnimplementedStatsGcsServiceServer should be embedded to have forward compatible implementations.
type UnimplementedStatsGcsServiceServer struct {
}

func (UnimplementedStatsGcsServiceServer) AddProfileData(context.Context, *AddProfileDataRequest) (*AddProfileDataReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddProfileData not implemented")
}
func (UnimplementedStatsGcsServiceServer) GetAllProfileInfo(context.Context, *GetAllProfileInfoRequest) (*GetAllProfileInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllProfileInfo not implemented")
}

// UnsafeStatsGcsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StatsGcsServiceServer will
// result in compilation errors.
type UnsafeStatsGcsServiceServer interface {
	mustEmbedUnimplementedStatsGcsServiceServer()
}

func RegisterStatsGcsServiceServer(s grpc.ServiceRegistrar, srv StatsGcsServiceServer) {
	s.RegisterService(&StatsGcsService_ServiceDesc, srv)
}

func _StatsGcsService_AddProfileData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddProfileDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatsGcsServiceServer).AddProfileData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.StatsGcsService/AddProfileData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatsGcsServiceServer).AddProfileData(ctx, req.(*AddProfileDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StatsGcsService_GetAllProfileInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllProfileInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatsGcsServiceServer).GetAllProfileInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.StatsGcsService/GetAllProfileInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatsGcsServiceServer).GetAllProfileInfo(ctx, req.(*GetAllProfileInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StatsGcsService_ServiceDesc is the grpc.ServiceDesc for StatsGcsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StatsGcsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ray.rpc.StatsGcsService",
	HandlerType: (*StatsGcsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddProfileData",
			Handler:    _StatsGcsService_AddProfileData_Handler,
		},
		{
			MethodName: "GetAllProfileInfo",
			Handler:    _StatsGcsService_GetAllProfileInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/ray/protobuf/gcs_service.proto",
}

// WorkerInfoGcsServiceClient is the client API for WorkerInfoGcsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WorkerInfoGcsServiceClient interface {
	// Report a worker failure to GCS Service.
	ReportWorkerFailure(ctx context.Context, in *ReportWorkerFailureRequest, opts ...grpc.CallOption) (*ReportWorkerFailureReply, error)
	// Get worker information from GCS Service by worker id.
	GetWorkerInfo(ctx context.Context, in *GetWorkerInfoRequest, opts ...grpc.CallOption) (*GetWorkerInfoReply, error)
	// Get information of all workers from GCS Service.
	GetAllWorkerInfo(ctx context.Context, in *GetAllWorkerInfoRequest, opts ...grpc.CallOption) (*GetAllWorkerInfoReply, error)
	// Add worker information to GCS Service.
	AddWorkerInfo(ctx context.Context, in *AddWorkerInfoRequest, opts ...grpc.CallOption) (*AddWorkerInfoReply, error)
}

type workerInfoGcsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkerInfoGcsServiceClient(cc grpc.ClientConnInterface) WorkerInfoGcsServiceClient {
	return &workerInfoGcsServiceClient{cc}
}

func (c *workerInfoGcsServiceClient) ReportWorkerFailure(ctx context.Context, in *ReportWorkerFailureRequest, opts ...grpc.CallOption) (*ReportWorkerFailureReply, error) {
	out := new(ReportWorkerFailureReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.WorkerInfoGcsService/ReportWorkerFailure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerInfoGcsServiceClient) GetWorkerInfo(ctx context.Context, in *GetWorkerInfoRequest, opts ...grpc.CallOption) (*GetWorkerInfoReply, error) {
	out := new(GetWorkerInfoReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.WorkerInfoGcsService/GetWorkerInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerInfoGcsServiceClient) GetAllWorkerInfo(ctx context.Context, in *GetAllWorkerInfoRequest, opts ...grpc.CallOption) (*GetAllWorkerInfoReply, error) {
	out := new(GetAllWorkerInfoReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.WorkerInfoGcsService/GetAllWorkerInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerInfoGcsServiceClient) AddWorkerInfo(ctx context.Context, in *AddWorkerInfoRequest, opts ...grpc.CallOption) (*AddWorkerInfoReply, error) {
	out := new(AddWorkerInfoReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.WorkerInfoGcsService/AddWorkerInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkerInfoGcsServiceServer is the server API for WorkerInfoGcsService service.
// All implementations should embed UnimplementedWorkerInfoGcsServiceServer
// for forward compatibility
type WorkerInfoGcsServiceServer interface {
	// Report a worker failure to GCS Service.
	ReportWorkerFailure(context.Context, *ReportWorkerFailureRequest) (*ReportWorkerFailureReply, error)
	// Get worker information from GCS Service by worker id.
	GetWorkerInfo(context.Context, *GetWorkerInfoRequest) (*GetWorkerInfoReply, error)
	// Get information of all workers from GCS Service.
	GetAllWorkerInfo(context.Context, *GetAllWorkerInfoRequest) (*GetAllWorkerInfoReply, error)
	// Add worker information to GCS Service.
	AddWorkerInfo(context.Context, *AddWorkerInfoRequest) (*AddWorkerInfoReply, error)
}

// UnimplementedWorkerInfoGcsServiceServer should be embedded to have forward compatible implementations.
type UnimplementedWorkerInfoGcsServiceServer struct {
}

func (UnimplementedWorkerInfoGcsServiceServer) ReportWorkerFailure(context.Context, *ReportWorkerFailureRequest) (*ReportWorkerFailureReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportWorkerFailure not implemented")
}
func (UnimplementedWorkerInfoGcsServiceServer) GetWorkerInfo(context.Context, *GetWorkerInfoRequest) (*GetWorkerInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkerInfo not implemented")
}
func (UnimplementedWorkerInfoGcsServiceServer) GetAllWorkerInfo(context.Context, *GetAllWorkerInfoRequest) (*GetAllWorkerInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllWorkerInfo not implemented")
}
func (UnimplementedWorkerInfoGcsServiceServer) AddWorkerInfo(context.Context, *AddWorkerInfoRequest) (*AddWorkerInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddWorkerInfo not implemented")
}

// UnsafeWorkerInfoGcsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkerInfoGcsServiceServer will
// result in compilation errors.
type UnsafeWorkerInfoGcsServiceServer interface {
	mustEmbedUnimplementedWorkerInfoGcsServiceServer()
}

func RegisterWorkerInfoGcsServiceServer(s grpc.ServiceRegistrar, srv WorkerInfoGcsServiceServer) {
	s.RegisterService(&WorkerInfoGcsService_ServiceDesc, srv)
}

func _WorkerInfoGcsService_ReportWorkerFailure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportWorkerFailureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerInfoGcsServiceServer).ReportWorkerFailure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.WorkerInfoGcsService/ReportWorkerFailure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerInfoGcsServiceServer).ReportWorkerFailure(ctx, req.(*ReportWorkerFailureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerInfoGcsService_GetWorkerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkerInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerInfoGcsServiceServer).GetWorkerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.WorkerInfoGcsService/GetWorkerInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerInfoGcsServiceServer).GetWorkerInfo(ctx, req.(*GetWorkerInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerInfoGcsService_GetAllWorkerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllWorkerInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerInfoGcsServiceServer).GetAllWorkerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.WorkerInfoGcsService/GetAllWorkerInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerInfoGcsServiceServer).GetAllWorkerInfo(ctx, req.(*GetAllWorkerInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerInfoGcsService_AddWorkerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddWorkerInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerInfoGcsServiceServer).AddWorkerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.WorkerInfoGcsService/AddWorkerInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerInfoGcsServiceServer).AddWorkerInfo(ctx, req.(*AddWorkerInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WorkerInfoGcsService_ServiceDesc is the grpc.ServiceDesc for WorkerInfoGcsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkerInfoGcsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ray.rpc.WorkerInfoGcsService",
	HandlerType: (*WorkerInfoGcsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReportWorkerFailure",
			Handler:    _WorkerInfoGcsService_ReportWorkerFailure_Handler,
		},
		{
			MethodName: "GetWorkerInfo",
			Handler:    _WorkerInfoGcsService_GetWorkerInfo_Handler,
		},
		{
			MethodName: "GetAllWorkerInfo",
			Handler:    _WorkerInfoGcsService_GetAllWorkerInfo_Handler,
		},
		{
			MethodName: "AddWorkerInfo",
			Handler:    _WorkerInfoGcsService_AddWorkerInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/ray/protobuf/gcs_service.proto",
}

// PlacementGroupInfoGcsServiceClient is the client API for PlacementGroupInfoGcsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PlacementGroupInfoGcsServiceClient interface {
	// Create placement group via gcs service.
	CreatePlacementGroup(ctx context.Context, in *CreatePlacementGroupRequest, opts ...grpc.CallOption) (*CreatePlacementGroupReply, error)
	// Remove placement group via gcs service.
	RemovePlacementGroup(ctx context.Context, in *RemovePlacementGroupRequest, opts ...grpc.CallOption) (*RemovePlacementGroupReply, error)
	// Get placement group information via gcs service.
	GetPlacementGroup(ctx context.Context, in *GetPlacementGroupRequest, opts ...grpc.CallOption) (*GetPlacementGroupReply, error)
	// Get named placement group information via gcs service.
	GetNamedPlacementGroup(ctx context.Context, in *GetNamedPlacementGroupRequest, opts ...grpc.CallOption) (*GetNamedPlacementGroupReply, error)
	// Get information of all placement group from GCS Service.
	GetAllPlacementGroup(ctx context.Context, in *GetAllPlacementGroupRequest, opts ...grpc.CallOption) (*GetAllPlacementGroupReply, error)
	// Wait for placement group until ready.
	WaitPlacementGroupUntilReady(ctx context.Context, in *WaitPlacementGroupUntilReadyRequest, opts ...grpc.CallOption) (*WaitPlacementGroupUntilReadyReply, error)
}

type placementGroupInfoGcsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPlacementGroupInfoGcsServiceClient(cc grpc.ClientConnInterface) PlacementGroupInfoGcsServiceClient {
	return &placementGroupInfoGcsServiceClient{cc}
}

func (c *placementGroupInfoGcsServiceClient) CreatePlacementGroup(ctx context.Context, in *CreatePlacementGroupRequest, opts ...grpc.CallOption) (*CreatePlacementGroupReply, error) {
	out := new(CreatePlacementGroupReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.PlacementGroupInfoGcsService/CreatePlacementGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *placementGroupInfoGcsServiceClient) RemovePlacementGroup(ctx context.Context, in *RemovePlacementGroupRequest, opts ...grpc.CallOption) (*RemovePlacementGroupReply, error) {
	out := new(RemovePlacementGroupReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.PlacementGroupInfoGcsService/RemovePlacementGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *placementGroupInfoGcsServiceClient) GetPlacementGroup(ctx context.Context, in *GetPlacementGroupRequest, opts ...grpc.CallOption) (*GetPlacementGroupReply, error) {
	out := new(GetPlacementGroupReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.PlacementGroupInfoGcsService/GetPlacementGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *placementGroupInfoGcsServiceClient) GetNamedPlacementGroup(ctx context.Context, in *GetNamedPlacementGroupRequest, opts ...grpc.CallOption) (*GetNamedPlacementGroupReply, error) {
	out := new(GetNamedPlacementGroupReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.PlacementGroupInfoGcsService/GetNamedPlacementGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *placementGroupInfoGcsServiceClient) GetAllPlacementGroup(ctx context.Context, in *GetAllPlacementGroupRequest, opts ...grpc.CallOption) (*GetAllPlacementGroupReply, error) {
	out := new(GetAllPlacementGroupReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.PlacementGroupInfoGcsService/GetAllPlacementGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *placementGroupInfoGcsServiceClient) WaitPlacementGroupUntilReady(ctx context.Context, in *WaitPlacementGroupUntilReadyRequest, opts ...grpc.CallOption) (*WaitPlacementGroupUntilReadyReply, error) {
	out := new(WaitPlacementGroupUntilReadyReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.PlacementGroupInfoGcsService/WaitPlacementGroupUntilReady", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PlacementGroupInfoGcsServiceServer is the server API for PlacementGroupInfoGcsService service.
// All implementations should embed UnimplementedPlacementGroupInfoGcsServiceServer
// for forward compatibility
type PlacementGroupInfoGcsServiceServer interface {
	// Create placement group via gcs service.
	CreatePlacementGroup(context.Context, *CreatePlacementGroupRequest) (*CreatePlacementGroupReply, error)
	// Remove placement group via gcs service.
	RemovePlacementGroup(context.Context, *RemovePlacementGroupRequest) (*RemovePlacementGroupReply, error)
	// Get placement group information via gcs service.
	GetPlacementGroup(context.Context, *GetPlacementGroupRequest) (*GetPlacementGroupReply, error)
	// Get named placement group information via gcs service.
	GetNamedPlacementGroup(context.Context, *GetNamedPlacementGroupRequest) (*GetNamedPlacementGroupReply, error)
	// Get information of all placement group from GCS Service.
	GetAllPlacementGroup(context.Context, *GetAllPlacementGroupRequest) (*GetAllPlacementGroupReply, error)
	// Wait for placement group until ready.
	WaitPlacementGroupUntilReady(context.Context, *WaitPlacementGroupUntilReadyRequest) (*WaitPlacementGroupUntilReadyReply, error)
}

// UnimplementedPlacementGroupInfoGcsServiceServer should be embedded to have forward compatible implementations.
type UnimplementedPlacementGroupInfoGcsServiceServer struct {
}

func (UnimplementedPlacementGroupInfoGcsServiceServer) CreatePlacementGroup(context.Context, *CreatePlacementGroupRequest) (*CreatePlacementGroupReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePlacementGroup not implemented")
}
func (UnimplementedPlacementGroupInfoGcsServiceServer) RemovePlacementGroup(context.Context, *RemovePlacementGroupRequest) (*RemovePlacementGroupReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemovePlacementGroup not implemented")
}
func (UnimplementedPlacementGroupInfoGcsServiceServer) GetPlacementGroup(context.Context, *GetPlacementGroupRequest) (*GetPlacementGroupReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPlacementGroup not implemented")
}
func (UnimplementedPlacementGroupInfoGcsServiceServer) GetNamedPlacementGroup(context.Context, *GetNamedPlacementGroupRequest) (*GetNamedPlacementGroupReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNamedPlacementGroup not implemented")
}
func (UnimplementedPlacementGroupInfoGcsServiceServer) GetAllPlacementGroup(context.Context, *GetAllPlacementGroupRequest) (*GetAllPlacementGroupReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllPlacementGroup not implemented")
}
func (UnimplementedPlacementGroupInfoGcsServiceServer) WaitPlacementGroupUntilReady(context.Context, *WaitPlacementGroupUntilReadyRequest) (*WaitPlacementGroupUntilReadyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitPlacementGroupUntilReady not implemented")
}

// UnsafePlacementGroupInfoGcsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PlacementGroupInfoGcsServiceServer will
// result in compilation errors.
type UnsafePlacementGroupInfoGcsServiceServer interface {
	mustEmbedUnimplementedPlacementGroupInfoGcsServiceServer()
}

func RegisterPlacementGroupInfoGcsServiceServer(s grpc.ServiceRegistrar, srv PlacementGroupInfoGcsServiceServer) {
	s.RegisterService(&PlacementGroupInfoGcsService_ServiceDesc, srv)
}

func _PlacementGroupInfoGcsService_CreatePlacementGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePlacementGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlacementGroupInfoGcsServiceServer).CreatePlacementGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.PlacementGroupInfoGcsService/CreatePlacementGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlacementGroupInfoGcsServiceServer).CreatePlacementGroup(ctx, req.(*CreatePlacementGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlacementGroupInfoGcsService_RemovePlacementGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePlacementGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlacementGroupInfoGcsServiceServer).RemovePlacementGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.PlacementGroupInfoGcsService/RemovePlacementGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlacementGroupInfoGcsServiceServer).RemovePlacementGroup(ctx, req.(*RemovePlacementGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlacementGroupInfoGcsService_GetPlacementGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPlacementGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlacementGroupInfoGcsServiceServer).GetPlacementGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.PlacementGroupInfoGcsService/GetPlacementGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlacementGroupInfoGcsServiceServer).GetPlacementGroup(ctx, req.(*GetPlacementGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlacementGroupInfoGcsService_GetNamedPlacementGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNamedPlacementGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlacementGroupInfoGcsServiceServer).GetNamedPlacementGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.PlacementGroupInfoGcsService/GetNamedPlacementGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlacementGroupInfoGcsServiceServer).GetNamedPlacementGroup(ctx, req.(*GetNamedPlacementGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlacementGroupInfoGcsService_GetAllPlacementGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllPlacementGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlacementGroupInfoGcsServiceServer).GetAllPlacementGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.PlacementGroupInfoGcsService/GetAllPlacementGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlacementGroupInfoGcsServiceServer).GetAllPlacementGroup(ctx, req.(*GetAllPlacementGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlacementGroupInfoGcsService_WaitPlacementGroupUntilReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitPlacementGroupUntilReadyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlacementGroupInfoGcsServiceServer).WaitPlacementGroupUntilReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.PlacementGroupInfoGcsService/WaitPlacementGroupUntilReady",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlacementGroupInfoGcsServiceServer).WaitPlacementGroupUntilReady(ctx, req.(*WaitPlacementGroupUntilReadyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PlacementGroupInfoGcsService_ServiceDesc is the grpc.ServiceDesc for PlacementGroupInfoGcsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PlacementGroupInfoGcsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ray.rpc.PlacementGroupInfoGcsService",
	HandlerType: (*PlacementGroupInfoGcsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePlacementGroup",
			Handler:    _PlacementGroupInfoGcsService_CreatePlacementGroup_Handler,
		},
		{
			MethodName: "RemovePlacementGroup",
			Handler:    _PlacementGroupInfoGcsService_RemovePlacementGroup_Handler,
		},
		{
			MethodName: "GetPlacementGroup",
			Handler:    _PlacementGroupInfoGcsService_GetPlacementGroup_Handler,
		},
		{
			MethodName: "GetNamedPlacementGroup",
			Handler:    _PlacementGroupInfoGcsService_GetNamedPlacementGroup_Handler,
		},
		{
			MethodName: "GetAllPlacementGroup",
			Handler:    _PlacementGroupInfoGcsService_GetAllPlacementGroup_Handler,
		},
		{
			MethodName: "WaitPlacementGroupUntilReady",
			Handler:    _PlacementGroupInfoGcsService_WaitPlacementGroupUntilReady_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/ray/protobuf/gcs_service.proto",
}

// InternalKVGcsServiceClient is the client API for InternalKVGcsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InternalKVGcsServiceClient interface {
	InternalKVGet(ctx context.Context, in *InternalKVGetRequest, opts ...grpc.CallOption) (*InternalKVGetReply, error)
	InternalKVPut(ctx context.Context, in *InternalKVPutRequest, opts ...grpc.CallOption) (*InternalKVPutReply, error)
	InternalKVDel(ctx context.Context, in *InternalKVDelRequest, opts ...grpc.CallOption) (*InternalKVDelReply, error)
	InternalKVExists(ctx context.Context, in *InternalKVExistsRequest, opts ...grpc.CallOption) (*InternalKVExistsReply, error)
	InternalKVKeys(ctx context.Context, in *InternalKVKeysRequest, opts ...grpc.CallOption) (*InternalKVKeysReply, error)
}

type internalKVGcsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInternalKVGcsServiceClient(cc grpc.ClientConnInterface) InternalKVGcsServiceClient {
	return &internalKVGcsServiceClient{cc}
}

func (c *internalKVGcsServiceClient) InternalKVGet(ctx context.Context, in *InternalKVGetRequest, opts ...grpc.CallOption) (*InternalKVGetReply, error) {
	out := new(InternalKVGetReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.InternalKVGcsService/InternalKVGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalKVGcsServiceClient) InternalKVPut(ctx context.Context, in *InternalKVPutRequest, opts ...grpc.CallOption) (*InternalKVPutReply, error) {
	out := new(InternalKVPutReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.InternalKVGcsService/InternalKVPut", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalKVGcsServiceClient) InternalKVDel(ctx context.Context, in *InternalKVDelRequest, opts ...grpc.CallOption) (*InternalKVDelReply, error) {
	out := new(InternalKVDelReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.InternalKVGcsService/InternalKVDel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalKVGcsServiceClient) InternalKVExists(ctx context.Context, in *InternalKVExistsRequest, opts ...grpc.CallOption) (*InternalKVExistsReply, error) {
	out := new(InternalKVExistsReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.InternalKVGcsService/InternalKVExists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalKVGcsServiceClient) InternalKVKeys(ctx context.Context, in *InternalKVKeysRequest, opts ...grpc.CallOption) (*InternalKVKeysReply, error) {
	out := new(InternalKVKeysReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.InternalKVGcsService/InternalKVKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InternalKVGcsServiceServer is the server API for InternalKVGcsService service.
// All implementations should embed UnimplementedInternalKVGcsServiceServer
// for forward compatibility
type InternalKVGcsServiceServer interface {
	InternalKVGet(context.Context, *InternalKVGetRequest) (*InternalKVGetReply, error)
	InternalKVPut(context.Context, *InternalKVPutRequest) (*InternalKVPutReply, error)
	InternalKVDel(context.Context, *InternalKVDelRequest) (*InternalKVDelReply, error)
	InternalKVExists(context.Context, *InternalKVExistsRequest) (*InternalKVExistsReply, error)
	InternalKVKeys(context.Context, *InternalKVKeysRequest) (*InternalKVKeysReply, error)
}

// UnimplementedInternalKVGcsServiceServer should be embedded to have forward compatible implementations.
type UnimplementedInternalKVGcsServiceServer struct {
}

func (UnimplementedInternalKVGcsServiceServer) InternalKVGet(context.Context, *InternalKVGetRequest) (*InternalKVGetReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InternalKVGet not implemented")
}
func (UnimplementedInternalKVGcsServiceServer) InternalKVPut(context.Context, *InternalKVPutRequest) (*InternalKVPutReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InternalKVPut not implemented")
}
func (UnimplementedInternalKVGcsServiceServer) InternalKVDel(context.Context, *InternalKVDelRequest) (*InternalKVDelReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InternalKVDel not implemented")
}
func (UnimplementedInternalKVGcsServiceServer) InternalKVExists(context.Context, *InternalKVExistsRequest) (*InternalKVExistsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InternalKVExists not implemented")
}
func (UnimplementedInternalKVGcsServiceServer) InternalKVKeys(context.Context, *InternalKVKeysRequest) (*InternalKVKeysReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InternalKVKeys not implemented")
}

// UnsafeInternalKVGcsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InternalKVGcsServiceServer will
// result in compilation errors.
type UnsafeInternalKVGcsServiceServer interface {
	mustEmbedUnimplementedInternalKVGcsServiceServer()
}

func RegisterInternalKVGcsServiceServer(s grpc.ServiceRegistrar, srv InternalKVGcsServiceServer) {
	s.RegisterService(&InternalKVGcsService_ServiceDesc, srv)
}

func _InternalKVGcsService_InternalKVGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InternalKVGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalKVGcsServiceServer).InternalKVGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.InternalKVGcsService/InternalKVGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalKVGcsServiceServer).InternalKVGet(ctx, req.(*InternalKVGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalKVGcsService_InternalKVPut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InternalKVPutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalKVGcsServiceServer).InternalKVPut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.InternalKVGcsService/InternalKVPut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalKVGcsServiceServer).InternalKVPut(ctx, req.(*InternalKVPutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalKVGcsService_InternalKVDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InternalKVDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalKVGcsServiceServer).InternalKVDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.InternalKVGcsService/InternalKVDel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalKVGcsServiceServer).InternalKVDel(ctx, req.(*InternalKVDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalKVGcsService_InternalKVExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InternalKVExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalKVGcsServiceServer).InternalKVExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.InternalKVGcsService/InternalKVExists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalKVGcsServiceServer).InternalKVExists(ctx, req.(*InternalKVExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalKVGcsService_InternalKVKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InternalKVKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalKVGcsServiceServer).InternalKVKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.InternalKVGcsService/InternalKVKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalKVGcsServiceServer).InternalKVKeys(ctx, req.(*InternalKVKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InternalKVGcsService_ServiceDesc is the grpc.ServiceDesc for InternalKVGcsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InternalKVGcsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ray.rpc.InternalKVGcsService",
	HandlerType: (*InternalKVGcsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InternalKVGet",
			Handler:    _InternalKVGcsService_InternalKVGet_Handler,
		},
		{
			MethodName: "InternalKVPut",
			Handler:    _InternalKVGcsService_InternalKVPut_Handler,
		},
		{
			MethodName: "InternalKVDel",
			Handler:    _InternalKVGcsService_InternalKVDel_Handler,
		},
		{
			MethodName: "InternalKVExists",
			Handler:    _InternalKVGcsService_InternalKVExists_Handler,
		},
		{
			MethodName: "InternalKVKeys",
			Handler:    _InternalKVGcsService_InternalKVKeys_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/ray/protobuf/gcs_service.proto",
}

// InternalPubSubGcsServiceClient is the client API for InternalPubSubGcsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InternalPubSubGcsServiceClient interface {
	// / The request to sent to GCS to publish messages.
	// / Currently only supporting error info, logs and Python function messages.
	GcsPublish(ctx context.Context, in *GcsPublishRequest, opts ...grpc.CallOption) (*GcsPublishReply, error)
	// / The long polling request sent to GCS for pubsub operations.
	// / The long poll request will be replied once there are a batch of messages that
	// / need to be published to the caller (subscriber).
	GcsSubscriberPoll(ctx context.Context, in *GcsSubscriberPollRequest, opts ...grpc.CallOption) (*GcsSubscriberPollReply, error)
	// / A batch of subscribe / unsubscribe requests sent by the subscriber.
	GcsSubscriberCommandBatch(ctx context.Context, in *GcsSubscriberCommandBatchRequest, opts ...grpc.CallOption) (*GcsSubscriberCommandBatchReply, error)
}

type internalPubSubGcsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInternalPubSubGcsServiceClient(cc grpc.ClientConnInterface) InternalPubSubGcsServiceClient {
	return &internalPubSubGcsServiceClient{cc}
}

func (c *internalPubSubGcsServiceClient) GcsPublish(ctx context.Context, in *GcsPublishRequest, opts ...grpc.CallOption) (*GcsPublishReply, error) {
	out := new(GcsPublishReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.InternalPubSubGcsService/GcsPublish", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalPubSubGcsServiceClient) GcsSubscriberPoll(ctx context.Context, in *GcsSubscriberPollRequest, opts ...grpc.CallOption) (*GcsSubscriberPollReply, error) {
	out := new(GcsSubscriberPollReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.InternalPubSubGcsService/GcsSubscriberPoll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalPubSubGcsServiceClient) GcsSubscriberCommandBatch(ctx context.Context, in *GcsSubscriberCommandBatchRequest, opts ...grpc.CallOption) (*GcsSubscriberCommandBatchReply, error) {
	out := new(GcsSubscriberCommandBatchReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.InternalPubSubGcsService/GcsSubscriberCommandBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InternalPubSubGcsServiceServer is the server API for InternalPubSubGcsService service.
// All implementations should embed UnimplementedInternalPubSubGcsServiceServer
// for forward compatibility
type InternalPubSubGcsServiceServer interface {
	// / The request to sent to GCS to publish messages.
	// / Currently only supporting error info, logs and Python function messages.
	GcsPublish(context.Context, *GcsPublishRequest) (*GcsPublishReply, error)
	// / The long polling request sent to GCS for pubsub operations.
	// / The long poll request will be replied once there are a batch of messages that
	// / need to be published to the caller (subscriber).
	GcsSubscriberPoll(context.Context, *GcsSubscriberPollRequest) (*GcsSubscriberPollReply, error)
	// / A batch of subscribe / unsubscribe requests sent by the subscriber.
	GcsSubscriberCommandBatch(context.Context, *GcsSubscriberCommandBatchRequest) (*GcsSubscriberCommandBatchReply, error)
}

// UnimplementedInternalPubSubGcsServiceServer should be embedded to have forward compatible implementations.
type UnimplementedInternalPubSubGcsServiceServer struct {
}

func (UnimplementedInternalPubSubGcsServiceServer) GcsPublish(context.Context, *GcsPublishRequest) (*GcsPublishReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GcsPublish not implemented")
}
func (UnimplementedInternalPubSubGcsServiceServer) GcsSubscriberPoll(context.Context, *GcsSubscriberPollRequest) (*GcsSubscriberPollReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GcsSubscriberPoll not implemented")
}
func (UnimplementedInternalPubSubGcsServiceServer) GcsSubscriberCommandBatch(context.Context, *GcsSubscriberCommandBatchRequest) (*GcsSubscriberCommandBatchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GcsSubscriberCommandBatch not implemented")
}

// UnsafeInternalPubSubGcsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InternalPubSubGcsServiceServer will
// result in compilation errors.
type UnsafeInternalPubSubGcsServiceServer interface {
	mustEmbedUnimplementedInternalPubSubGcsServiceServer()
}

func RegisterInternalPubSubGcsServiceServer(s grpc.ServiceRegistrar, srv InternalPubSubGcsServiceServer) {
	s.RegisterService(&InternalPubSubGcsService_ServiceDesc, srv)
}

func _InternalPubSubGcsService_GcsPublish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GcsPublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalPubSubGcsServiceServer).GcsPublish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.InternalPubSubGcsService/GcsPublish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalPubSubGcsServiceServer).GcsPublish(ctx, req.(*GcsPublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalPubSubGcsService_GcsSubscriberPoll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GcsSubscriberPollRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalPubSubGcsServiceServer).GcsSubscriberPoll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.InternalPubSubGcsService/GcsSubscriberPoll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalPubSubGcsServiceServer).GcsSubscriberPoll(ctx, req.(*GcsSubscriberPollRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalPubSubGcsService_GcsSubscriberCommandBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GcsSubscriberCommandBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalPubSubGcsServiceServer).GcsSubscriberCommandBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.InternalPubSubGcsService/GcsSubscriberCommandBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalPubSubGcsServiceServer).GcsSubscriberCommandBatch(ctx, req.(*GcsSubscriberCommandBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InternalPubSubGcsService_ServiceDesc is the grpc.ServiceDesc for InternalPubSubGcsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InternalPubSubGcsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ray.rpc.InternalPubSubGcsService",
	HandlerType: (*InternalPubSubGcsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GcsPublish",
			Handler:    _InternalPubSubGcsService_GcsPublish_Handler,
		},
		{
			MethodName: "GcsSubscriberPoll",
			Handler:    _InternalPubSubGcsService_GcsSubscriberPoll_Handler,
		},
		{
			MethodName: "GcsSubscriberCommandBatch",
			Handler:    _InternalPubSubGcsService_GcsSubscriberCommandBatch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/ray/protobuf/gcs_service.proto",
}

// NodeResourceInfoGcsServiceClient is the client API for NodeResourceInfoGcsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeResourceInfoGcsServiceClient interface {
	// Get node's resources from GCS Service.
	GetResources(ctx context.Context, in *GetResourcesRequest, opts ...grpc.CallOption) (*GetResourcesReply, error)
	// Get available resources of all nodes.
	GetAllAvailableResources(ctx context.Context, in *GetAllAvailableResourcesRequest, opts ...grpc.CallOption) (*GetAllAvailableResourcesReply, error)
	// Report resource usage of a node to GCS Service.
	ReportResourceUsage(ctx context.Context, in *ReportResourceUsageRequest, opts ...grpc.CallOption) (*ReportResourceUsageReply, error)
	// Get resource usage of all nodes from GCS Service.
	GetAllResourceUsage(ctx context.Context, in *GetAllResourceUsageRequest, opts ...grpc.CallOption) (*GetAllResourceUsageReply, error)
}

type nodeResourceInfoGcsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeResourceInfoGcsServiceClient(cc grpc.ClientConnInterface) NodeResourceInfoGcsServiceClient {
	return &nodeResourceInfoGcsServiceClient{cc}
}

func (c *nodeResourceInfoGcsServiceClient) GetResources(ctx context.Context, in *GetResourcesRequest, opts ...grpc.CallOption) (*GetResourcesReply, error) {
	out := new(GetResourcesReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.NodeResourceInfoGcsService/GetResources", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeResourceInfoGcsServiceClient) GetAllAvailableResources(ctx context.Context, in *GetAllAvailableResourcesRequest, opts ...grpc.CallOption) (*GetAllAvailableResourcesReply, error) {
	out := new(GetAllAvailableResourcesReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.NodeResourceInfoGcsService/GetAllAvailableResources", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeResourceInfoGcsServiceClient) ReportResourceUsage(ctx context.Context, in *ReportResourceUsageRequest, opts ...grpc.CallOption) (*ReportResourceUsageReply, error) {
	out := new(ReportResourceUsageReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.NodeResourceInfoGcsService/ReportResourceUsage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeResourceInfoGcsServiceClient) GetAllResourceUsage(ctx context.Context, in *GetAllResourceUsageRequest, opts ...grpc.CallOption) (*GetAllResourceUsageReply, error) {
	out := new(GetAllResourceUsageReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.NodeResourceInfoGcsService/GetAllResourceUsage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeResourceInfoGcsServiceServer is the server API for NodeResourceInfoGcsService service.
// All implementations should embed UnimplementedNodeResourceInfoGcsServiceServer
// for forward compatibility
type NodeResourceInfoGcsServiceServer interface {
	// Get node's resources from GCS Service.
	GetResources(context.Context, *GetResourcesRequest) (*GetResourcesReply, error)
	// Get available resources of all nodes.
	GetAllAvailableResources(context.Context, *GetAllAvailableResourcesRequest) (*GetAllAvailableResourcesReply, error)
	// Report resource usage of a node to GCS Service.
	ReportResourceUsage(context.Context, *ReportResourceUsageRequest) (*ReportResourceUsageReply, error)
	// Get resource usage of all nodes from GCS Service.
	GetAllResourceUsage(context.Context, *GetAllResourceUsageRequest) (*GetAllResourceUsageReply, error)
}

// UnimplementedNodeResourceInfoGcsServiceServer should be embedded to have forward compatible implementations.
type UnimplementedNodeResourceInfoGcsServiceServer struct {
}

func (UnimplementedNodeResourceInfoGcsServiceServer) GetResources(context.Context, *GetResourcesRequest) (*GetResourcesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetResources not implemented")
}
func (UnimplementedNodeResourceInfoGcsServiceServer) GetAllAvailableResources(context.Context, *GetAllAvailableResourcesRequest) (*GetAllAvailableResourcesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllAvailableResources not implemented")
}
func (UnimplementedNodeResourceInfoGcsServiceServer) ReportResourceUsage(context.Context, *ReportResourceUsageRequest) (*ReportResourceUsageReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportResourceUsage not implemented")
}
func (UnimplementedNodeResourceInfoGcsServiceServer) GetAllResourceUsage(context.Context, *GetAllResourceUsageRequest) (*GetAllResourceUsageReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllResourceUsage not implemented")
}

// UnsafeNodeResourceInfoGcsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeResourceInfoGcsServiceServer will
// result in compilation errors.
type UnsafeNodeResourceInfoGcsServiceServer interface {
	mustEmbedUnimplementedNodeResourceInfoGcsServiceServer()
}

func RegisterNodeResourceInfoGcsServiceServer(s grpc.ServiceRegistrar, srv NodeResourceInfoGcsServiceServer) {
	s.RegisterService(&NodeResourceInfoGcsService_ServiceDesc, srv)
}

func _NodeResourceInfoGcsService_GetResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetResourcesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeResourceInfoGcsServiceServer).GetResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.NodeResourceInfoGcsService/GetResources",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeResourceInfoGcsServiceServer).GetResources(ctx, req.(*GetResourcesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeResourceInfoGcsService_GetAllAvailableResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllAvailableResourcesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeResourceInfoGcsServiceServer).GetAllAvailableResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.NodeResourceInfoGcsService/GetAllAvailableResources",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeResourceInfoGcsServiceServer).GetAllAvailableResources(ctx, req.(*GetAllAvailableResourcesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeResourceInfoGcsService_ReportResourceUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportResourceUsageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeResourceInfoGcsServiceServer).ReportResourceUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.NodeResourceInfoGcsService/ReportResourceUsage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeResourceInfoGcsServiceServer).ReportResourceUsage(ctx, req.(*ReportResourceUsageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeResourceInfoGcsService_GetAllResourceUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllResourceUsageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeResourceInfoGcsServiceServer).GetAllResourceUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.NodeResourceInfoGcsService/GetAllResourceUsage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeResourceInfoGcsServiceServer).GetAllResourceUsage(ctx, req.(*GetAllResourceUsageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeResourceInfoGcsService_ServiceDesc is the grpc.ServiceDesc for NodeResourceInfoGcsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeResourceInfoGcsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ray.rpc.NodeResourceInfoGcsService",
	HandlerType: (*NodeResourceInfoGcsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetResources",
			Handler:    _NodeResourceInfoGcsService_GetResources_Handler,
		},
		{
			MethodName: "GetAllAvailableResources",
			Handler:    _NodeResourceInfoGcsService_GetAllAvailableResources_Handler,
		},
		{
			MethodName: "ReportResourceUsage",
			Handler:    _NodeResourceInfoGcsService_ReportResourceUsage_Handler,
		},
		{
			MethodName: "GetAllResourceUsage",
			Handler:    _NodeResourceInfoGcsService_GetAllResourceUsage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/ray/protobuf/gcs_service.proto",
}

// NodeInfoGcsServiceClient is the client API for NodeInfoGcsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeInfoGcsServiceClient interface {
	// Register a node to GCS Service.
	RegisterNode(ctx context.Context, in *RegisterNodeRequest, opts ...grpc.CallOption) (*RegisterNodeReply, error)
	// Drain a node from GCS Service.
	// When the RPC is replied,
	// - It is guaranteed that the requested nodes are going to be drained eventually.
	// - It is guaranteed that GCS has persisted the draining states.
	// - It is **not** guarateed that nodes receive the drain requests from GCS.
	DrainNode(ctx context.Context, in *DrainNodeRequest, opts ...grpc.CallOption) (*DrainNodeReply, error)
	// Get information of all nodes from GCS Service.
	GetAllNodeInfo(ctx context.Context, in *GetAllNodeInfoRequest, opts ...grpc.CallOption) (*GetAllNodeInfoReply, error)
	// Get cluster internal config.
	GetInternalConfig(ctx context.Context, in *GetInternalConfigRequest, opts ...grpc.CallOption) (*GetInternalConfigReply, error)
}

type nodeInfoGcsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeInfoGcsServiceClient(cc grpc.ClientConnInterface) NodeInfoGcsServiceClient {
	return &nodeInfoGcsServiceClient{cc}
}

func (c *nodeInfoGcsServiceClient) RegisterNode(ctx context.Context, in *RegisterNodeRequest, opts ...grpc.CallOption) (*RegisterNodeReply, error) {
	out := new(RegisterNodeReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.NodeInfoGcsService/RegisterNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeInfoGcsServiceClient) DrainNode(ctx context.Context, in *DrainNodeRequest, opts ...grpc.CallOption) (*DrainNodeReply, error) {
	out := new(DrainNodeReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.NodeInfoGcsService/DrainNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeInfoGcsServiceClient) GetAllNodeInfo(ctx context.Context, in *GetAllNodeInfoRequest, opts ...grpc.CallOption) (*GetAllNodeInfoReply, error) {
	out := new(GetAllNodeInfoReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.NodeInfoGcsService/GetAllNodeInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeInfoGcsServiceClient) GetInternalConfig(ctx context.Context, in *GetInternalConfigRequest, opts ...grpc.CallOption) (*GetInternalConfigReply, error) {
	out := new(GetInternalConfigReply)
	err := c.cc.Invoke(ctx, "/ray.rpc.NodeInfoGcsService/GetInternalConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeInfoGcsServiceServer is the server API for NodeInfoGcsService service.
// All implementations should embed UnimplementedNodeInfoGcsServiceServer
// for forward compatibility
type NodeInfoGcsServiceServer interface {
	// Register a node to GCS Service.
	RegisterNode(context.Context, *RegisterNodeRequest) (*RegisterNodeReply, error)
	// Drain a node from GCS Service.
	// When the RPC is replied,
	// - It is guaranteed that the requested nodes are going to be drained eventually.
	// - It is guaranteed that GCS has persisted the draining states.
	// - It is **not** guarateed that nodes receive the drain requests from GCS.
	DrainNode(context.Context, *DrainNodeRequest) (*DrainNodeReply, error)
	// Get information of all nodes from GCS Service.
	GetAllNodeInfo(context.Context, *GetAllNodeInfoRequest) (*GetAllNodeInfoReply, error)
	// Get cluster internal config.
	GetInternalConfig(context.Context, *GetInternalConfigRequest) (*GetInternalConfigReply, error)
}

// UnimplementedNodeInfoGcsServiceServer should be embedded to have forward compatible implementations.
type UnimplementedNodeInfoGcsServiceServer struct {
}

func (UnimplementedNodeInfoGcsServiceServer) RegisterNode(context.Context, *RegisterNodeRequest) (*RegisterNodeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterNode not implemented")
}
func (UnimplementedNodeInfoGcsServiceServer) DrainNode(context.Context, *DrainNodeRequest) (*DrainNodeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DrainNode not implemented")
}
func (UnimplementedNodeInfoGcsServiceServer) GetAllNodeInfo(context.Context, *GetAllNodeInfoRequest) (*GetAllNodeInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllNodeInfo not implemented")
}
func (UnimplementedNodeInfoGcsServiceServer) GetInternalConfig(context.Context, *GetInternalConfigRequest) (*GetInternalConfigReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInternalConfig not implemented")
}

// UnsafeNodeInfoGcsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeInfoGcsServiceServer will
// result in compilation errors.
type UnsafeNodeInfoGcsServiceServer interface {
	mustEmbedUnimplementedNodeInfoGcsServiceServer()
}

func RegisterNodeInfoGcsServiceServer(s grpc.ServiceRegistrar, srv NodeInfoGcsServiceServer) {
	s.RegisterService(&NodeInfoGcsService_ServiceDesc, srv)
}

func _NodeInfoGcsService_RegisterNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeInfoGcsServiceServer).RegisterNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.NodeInfoGcsService/RegisterNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeInfoGcsServiceServer).RegisterNode(ctx, req.(*RegisterNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeInfoGcsService_DrainNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DrainNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeInfoGcsServiceServer).DrainNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.NodeInfoGcsService/DrainNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeInfoGcsServiceServer).DrainNode(ctx, req.(*DrainNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeInfoGcsService_GetAllNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllNodeInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeInfoGcsServiceServer).GetAllNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.NodeInfoGcsService/GetAllNodeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeInfoGcsServiceServer).GetAllNodeInfo(ctx, req.(*GetAllNodeInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeInfoGcsService_GetInternalConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInternalConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeInfoGcsServiceServer).GetInternalConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ray.rpc.NodeInfoGcsService/GetInternalConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeInfoGcsServiceServer).GetInternalConfig(ctx, req.(*GetInternalConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeInfoGcsService_ServiceDesc is the grpc.ServiceDesc for NodeInfoGcsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeInfoGcsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ray.rpc.NodeInfoGcsService",
	HandlerType: (*NodeInfoGcsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterNode",
			Handler:    _NodeInfoGcsService_RegisterNode_Handler,
		},
		{
			MethodName: "DrainNode",
			Handler:    _NodeInfoGcsService_DrainNode_Handler,
		},
		{
			MethodName: "GetAllNodeInfo",
			Handler:    _NodeInfoGcsService_GetAllNodeInfo_Handler,
		},
		{
			MethodName: "GetInternalConfig",
			Handler:    _NodeInfoGcsService_GetInternalConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "src/ray/protobuf/gcs_service.proto",
}
